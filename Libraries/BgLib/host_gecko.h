#ifndef host_gecko_h
#define host_gecko_h

/*****************************************************************************
 *
 *  Native BGAPI
 *
 *  Autogenerated file, do not edit
 *
 ****************************************************************************/
 
#include <string.h>


#include "bg_types.h"

#include "gecko_configuration.h"

/* Compability */
#ifndef PACKSTRUCT
/*Default packed configuration*/
#ifdef __GNUC__
#ifdef _WIN32
#define PACKSTRUCT( decl ) decl __attribute__((__packed__,gcc_struct))
#else
#define PACKSTRUCT( decl ) decl __attribute__((__packed__))
#endif
#define ALIGNED __attribute__((aligned(0x4)))
#elif __IAR_SYSTEMS_ICC__

#define PACKSTRUCT( decl ) __packed decl

#define ALIGNED
#elif _MSC_VER  //msvc

#define PACKSTRUCT( decl ) __pragma( pack(push, 1) ) decl __pragma( pack(pop) )
#define ALIGNED
#else 
#define PACKSTRUCT(a) a PACKED 
#endif
#endif


#define BGLIB_MSG_ID(HDR) ((HDR)&0xffff00f8)
#define BGLIB_MSG_HEADER_LEN (4)
#define BGLIB_MSG_LEN(HDR) ((((HDR)&0x7)<<8)|(((HDR)&0xff00)>>8))

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Blocks until new event arrives which requires processing by user application.
 * 
 * @return pointer to received event
 */
struct gecko_cmd_packet* gecko_wait_event(void);

/**
 * Same as gecko_wait_event but does not block if no events waiting, instead returns NULL
 *
 * @return pointer to received event or NULL if no event waiting
 */
struct gecko_cmd_packet* gecko_peek_event(void);

/**
 * Events are in queue waiting for processing
 * Call gecko_wait_event or gecko_peek_event to process pending events
 *
 * @return nonzero if processing required
 */
int gecko_event_pending(void);

/**
 *  Initialize stack
 *  @param config if set as NULL uses default values for all configuration parameters
 */
void gecko_init(const gecko_configuration_t *config);

/**
 * Poll the stack how long it can sleep
 * @return maximum sleep time in milliseconds; 0 if cannot sleep
 */
uint32 gecko_can_sleep_ms(void);

/**
 * Priority message handler function if user application requires the use of PendSV interrupt.
 *
 * If scheduler_callback function pointer in configuration struct is something else than NULL,
 * then stack will not install its own PendSV IRQ handler but instead uses callback/handler functions.
 *
 * When application receives call to the scheduler_callback function it must schedule the call to
 * gecko_priority_handle function to later time to run on high priority thread. This callback
 * may happen inside radio IRQ so processing must not block and has to happen as fast as possible.
 *
 * Recommended implemenation:
 * High priority thread is loop that waits on binary semaphore and calls gecko_priority_handler.
 * The scheduler_callback is simple function that only signals the semaphore.
 *
 */
void gecko_priority_handle(void);

/**
 * Put the stack to sleep for a maximum of @param max milliseconds.
 * Note that the stack may wake up earlier due to an external event.
 * @return number of milliseconds actually slept.
 */
uint32 gecko_sleep_for_ms(uint32 max);


enum bt_gap_discover_mode
{
	bt_gap_discover_generic = 0,
	bt_gap_discover_limited = 1,
	bt_gap_discover_mode_max= 2
};

enum le_gap_address_type
{
	le_gap_address_type_public          = 0,
	le_gap_address_type_random          = 1,
	le_gap_address_type_public_identity = 2,
	le_gap_address_type_random_identity = 3,
	le_gap_address_type_bredr           = 16,
	le_gap_address_type_max             = 17
};

enum le_gap_connectable_mode
{
	le_gap_non_connectable           = 0,
	le_gap_directed_connectable      = 1,
	le_gap_undirected_connectable    = 2,
	le_gap_scannable_non_connectable = 3,
	le_gap_connectable_mode_max      = 4
};

enum le_gap_discoverable_mode
{
	le_gap_non_discoverable     = 0,
	le_gap_limited_discoverable = 1,
	le_gap_general_discoverable = 2,
	le_gap_broadcast            = 3,
	le_gap_user_data            = 4,
	le_gap_discoverable_mode_max= 5
};

enum le_gap_discover_mode
{
	le_gap_discover_limited     = 0,
	le_gap_discover_generic     = 1,
	le_gap_discover_observation = 2,
	le_gap_discover_mode_max    = 3
};

enum bt_connection_direction
{
	bt_connection_outgoing = 0,
	bt_connection_incoming = 1,
	bt_connection_direction_max= 2
};

enum bt_connection_powermode
{
	bt_connection_active = 0,
	bt_connection_hold   = 1,
	bt_connection_sniff  = 2,
	bt_connection_park   = 3,
	bt_connection_powermode_max= 4
};

enum bt_connection_role
{
	bt_connection_master = 0,
	bt_connection_slave  = 1,
	bt_connection_role_max= 2
};

enum bt_connection_encryption
{
	bt_connection_encrypted = 0,
	bt_connection_plain     = 1,
	bt_connection_encryption_max= 2
};

enum le_connection_security
{
	le_connection_mode1_level1 = 0,
	le_connection_mode1_level2 = 1,
	le_connection_mode1_level3 = 2,
	le_connection_security_max = 3
};

enum gatt_att_opcode
{
	gatt_read_by_type_request      = 0x08,
	gatt_read_by_type_response     = 0x09,
	gatt_read_request              = 0x0a,
	gatt_read_response             = 0x0b,
	gatt_read_blob_request         = 0x0c,
	gatt_read_blob_response        = 0x0d,
	gatt_read_multiple_request     = 0x0e,
	gatt_read_multiple_response    = 0x0f,
	gatt_write_request             = 0x12,
	gatt_write_response            = 0x13,
	gatt_write_command             = 0x52,
	gatt_prepare_write_request     = 0x16,
	gatt_prepare_write_response    = 0x17,
	gatt_execute_write_request     = 0x18,
	gatt_execute_write_response    = 0x19,
	gatt_handle_value_notification = 0x1b,
	gatt_handle_value_indication   = 0x1d,
	gatt_att_opcode_max            = 30
};

enum gatt_client_config_flag
{
	gatt_disable      = 0x0,
	gatt_notification = 0x1,
	gatt_indication   = 0x2,
	gatt_client_config_flag_max= 3
};

enum gatt_execute_write_flag
{
	gatt_cancel = 0x0,
	gatt_commit = 0x1,
	gatt_execute_write_flag_max= 2
};

enum gatt_server_characteristic_status_flag
{
	gatt_server_client_config = 0x1,
	gatt_server_confirmation  = 0x2,
	gatt_server_characteristic_status_flag_max= 3
};

#define ENDPOINT_FLAG_UPDATED    0x01
#define ENDPOINT_FLAG_ACTIVE     0x02
#define ENDPOINT_FLAG_STREAMING  0x04
#define ENDPOINT_FLAG_BGAPI      0x08
#define ENDPOINT_FLAG_WAIT_CLOSE 0x10
#define ENDPOINT_FLAG_CLOSING    0x20

enum endpoint_types
{
	endpoint_free       = 0x0,
	endpoint_uart       = 0x1,
	endpoint_script     = 0x2,
	endpoint_reserved   = 0x4,
	endpoint_drop       = 0x10,
	endpoint_rfcomm     = 0x20,
	endpoint_spi        = 0x40,
	endpoint_connection = 0x80,
	endpoint_native     = 0x100,
	endpoint_types_max  = 257
};

enum hardware_gpio_mode
{
	hardware_gpio_mode_disabled          = 0x0,
	hardware_gpio_mode_input             = 0x1,
	hardware_gpio_mode_input_pull        = 0x2,
	hardware_gpio_mode_input_pull_filter = 0x3,
	hardware_gpio_mode_push_pull         = 0x4,
	hardware_gpio_mode_max               = 5
};

enum hardware_adc_reference
{
	hardware_adc_reference_1v25      = 0x0,
	hardware_adc_reference_2v5       = 0x1,
	hardware_adc_reference_vdd       = 0x2,
	hardware_adc_reference_5vdiff    = 0x3,
	hardware_adc_reference_extsingle = 0x4,
	hardware_adc_reference_2xextdiff = 0x5,
	hardware_adc_reference_2xvdd     = 0x6,
	hardware_adc_reference_max       = 7
};

enum hardware_adc_channel
{
	hardware_adc_channel_avdd     = 224,
	hardware_adc_channel_dvdd     = 226,
	hardware_adc_channel_decouple = 228,
	hardware_adc_channel_iovdd    = 229,
	hardware_adc_channel_temp     = 243,
	hardware_adc_channel_vss      = 255,
	hardware_adc_channel_max      = 256
};

enum hardware_uartparity
{
	hardware_parity_none = 0x0,
	hardware_parity_odd  = 0x1,
	hardware_parity_even = 0x2,
	hardware_uartparity_max= 3
};

#define FLASH_PS_KEY_BD_ADDR                     1
#define FLASH_PS_KEY_LOCAL_NAME                  4
#define FLASH_PS_KEY_BT_CLASS                    5
#define FLASH_PS_KEY_IWRAP_PAGE_MODE             6
#define FLASH_PS_KEY_IWRAP_PAGE_TIMEOUT          7
#define FLASH_PS_KEY_IWRAP_PAGE_SCAN_MODE        8
#define FLASH_PS_KEY_IWRAP_ALT_PAGE_MODE         9
#define FLASH_PS_KEY_IWRAP_PAGE_CONN_COUNT       10
#define FLASH_PS_KEY_IWRAP_MS_POLICY             11
#define FLASH_PS_KEY_IWRAP_LINK_POLICY           12
#define FLASH_PS_KEY_IWRAP_SUPERVISION_TIMEOUT   13
#define FLASH_PS_KEY_SNIFF_MAX_INTERVAL          14
#define FLASH_PS_KEY_SNIFF_MIN_INTERVAL          15
#define FLASH_PS_KEY_SNIFF_ATTEMPTS              16
#define FLASH_PS_KEY_SNIFF_TIMEOUT               17
#define FLASH_PS_KEY_IO_CAPABILITIES             18
#define FLASH_PS_KEY_MITM                        19
#define FLASH_PS_KEY_IWRAP_CONTROL_ECHO          20
#define FLASH_PS_KEY_UART_SPEED                  21
#define FLASH_PS_KEY_PROFILE_SPP                 22
#define FLASH_PS_KEY_PORTA_PIO_DIRECTION         23
#define FLASH_PS_KEY_PORTB_PIO_DIRECTION         24
#define FLASH_PS_KEY_PORTA_PIO_BIAS              25
#define FLASH_PS_KEY_PORTB_PIO_BIAS              26
#define FLASH_PS_KEY_PORTA_PIO_PULL_UP           27
#define FLASH_PS_KEY_PORTB_PIO_PULL_UP           28
#define FLASH_PS_KEY_IWRAP_I2C_STATUS            29
#define FLASH_PS_KEY_IWRAP_SPI_STATUS            30
#define FLASH_PS_KEY_MAXPAIRCOUNT                31
#define FLASH_PS_KEY_LAST_DELETED_PAIR           32
#define FLASH_PS_KEY_IWRAP_CD_MASK               33
#define FLASH_PS_KEY_IWRAP_CD_DATA_MASK          34
#define FLASH_PS_KEY_IWRAP_CD_MODE               35
#define FLASH_PS_KEY_IWRAP_AUTH_PIN_VISIBLE      36
#define FLASH_PS_KEY_AUTH_PIN                    37
#define FLASH_PS_KEY_IWRAP_READY_MASK            38
#define FLASH_PS_KEY_IWRAP_ESC_CHAR              39
#define FLASH_PS_KEY_IWRAP_DTR_PIO_MASK          40
#define FLASH_PS_KEY_IWRAP_DTR_MODE              41
#define FLASH_PS_KEY_MINIMUM_ENCRYPTION_KEY_SIZE 42
#define FLASH_PS_KEY_INQUIRY_SCAN_LAP            43
#define FLASH_PS_KEY_LOCAL_BD_ADDR               44
#define FLASH_PS_KEY_AUTOCALL                    45
#define FLASH_PS_KEY_AUTOCALL_DUMMY              46
#define FLASH_PS_KEY_LAP                         47
#define FLASH_PS_KEY_CONNAUTH                    48
#define FLASH_PS_KEY_TX_POWER                    49
#define FLASH_PS_KEY_CTUNE                       50

enum test_packet_type
{
	test_pkt_prbs9    = 0x0,
	test_pkt_11110000 = 0x1,
	test_pkt_10101010 = 0x2,
	test_pkt_carrier  = 0x3,
	test_packet_type_max= 4
};

enum sm_bonding_key
{
	sm_bonding_key_ltk         = 0x01,
	sm_bonding_key_addr_public = 0x02,
	sm_bonding_key_addr_static = 0x04,
	sm_bonding_key_irk         = 0x08,
	sm_bonding_key_edivrand    = 0x10,
	sm_bonding_key_csrk        = 0x20,
	sm_bonding_key_masterid    = 0x40,
	sm_bonding_key_max         = 65
};

enum sm_io_capability
{
	sm_io_capability_displayonly     = 0,
	sm_io_capability_displayyesno    = 1,
	sm_io_capability_keyboardonly    = 2,
	sm_io_capability_noinputnooutput = 3,
	sm_io_capability_keyboarddisplay = 4,
	sm_io_capability_max             = 5
};

enum homekit_category
{
	homekit_not_allowed         = 0,
	homekit_other               = 1,
	homekit_bridge              = 2,
	homekit_fan                 = 3,
	homekit_garage              = 4,
	homekit_lightbulb           = 5,
	homekit_doorlock            = 6,
	homekit_outlet              = 7,
	homekit_switch_accessory    = 8,
	homekit_thermostat          = 9,
	homekit_sensor              = 10,
	homekit_security_system     = 11,
	homekit_door                = 12,
	homekit_window              = 13,
	homekit_window_covering     = 14,
	homekit_programmable_switch = 15,
	homekit_category_max        = 16
};


enum gecko_parameter_types
{
    gecko_msg_parameter_uint8=2,
    gecko_msg_parameter_int8=3,
    gecko_msg_parameter_uint16=4,
    gecko_msg_parameter_int16=5,
    gecko_msg_parameter_uint32=6,
    gecko_msg_parameter_int32=7,
    gecko_msg_parameter_uint8array=8,
    gecko_msg_parameter_string=9,
    gecko_msg_parameter_hwaddr=10,
    gecko_msg_parameter_uint16array=11
};

enum gecko_msg_types
{
    gecko_msg_type_cmd=0x00,
    gecko_msg_type_rsp=0x00,
    gecko_msg_type_evt=0x80
};
enum gecko_dev_types
{
    gecko_dev_type_ble    =0x00,
    gecko_dev_type_wifi   =0x08,
    gecko_dev_type_iwrap  =0x10,
    gecko_dev_type_dumo   =0x20,
    gecko_dev_type_test   =0x20,
    gecko_dev_type_gecko   =0x20
};

#define	gecko_cmd_dfu_reset_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00000000)
#define	gecko_cmd_dfu_flash_set_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01000000)
#define	gecko_cmd_dfu_flash_upload_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02000000)
#define	gecko_cmd_dfu_flash_upload_finish_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03000000)
#define	gecko_cmd_system_hello_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00010000)
#define	gecko_cmd_system_reset_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01010000)
#define	gecko_cmd_system_get_bt_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03010000)
#define	gecko_cmd_system_set_tx_power_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0A010000)
#define	gecko_cmd_system_get_random_data_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0B010000)
#define	gecko_cmd_le_gap_open_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00030000)
#define	gecko_cmd_le_gap_set_mode_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01030000)
#define	gecko_cmd_le_gap_discover_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02030000)
#define	gecko_cmd_le_gap_end_procedure_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03030000)
#define	gecko_cmd_le_gap_set_adv_parameters_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04030000)
#define	gecko_cmd_le_gap_set_conn_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05030000)
#define	gecko_cmd_le_gap_set_scan_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06030000)
#define	gecko_cmd_le_gap_set_adv_data_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07030000)
#define	gecko_cmd_le_gap_set_adv_timeout_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08030000)
#define	gecko_cmd_le_connection_set_parameters_id                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00080000)
#define	gecko_cmd_le_connection_get_rssi_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01080000)
#define	gecko_cmd_le_connection_disable_slave_latency_id             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02080000)
#define	gecko_cmd_gatt_set_max_mtu_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00090000)
#define	gecko_cmd_gatt_discover_primary_services_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01090000)
#define	gecko_cmd_gatt_discover_primary_services_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02090000)
#define	gecko_cmd_gatt_discover_characteristics_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03090000)
#define	gecko_cmd_gatt_discover_characteristics_by_uuid_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04090000)
#define	gecko_cmd_gatt_set_characteristic_notification_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05090000)
#define	gecko_cmd_gatt_discover_descriptors_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06090000)
#define	gecko_cmd_gatt_read_characteristic_value_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07090000)
#define	gecko_cmd_gatt_read_characteristic_value_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08090000)
#define	gecko_cmd_gatt_write_characteristic_value_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09090000)
#define	gecko_cmd_gatt_write_characteristic_value_without_response_id	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0A090000)
#define	gecko_cmd_gatt_prepare_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0B090000)
#define	gecko_cmd_gatt_execute_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0C090000)
#define	gecko_cmd_gatt_send_characteristic_confirmation_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0D090000)
#define	gecko_cmd_gatt_read_descriptor_value_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0E090000)
#define	gecko_cmd_gatt_write_descriptor_value_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0F090000)
#define	gecko_cmd_gatt_find_included_services_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10090000)
#define	gecko_cmd_gatt_read_multiple_characteristic_values_id        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11090000)
#define	gecko_cmd_gatt_server_read_attribute_value_id                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000A0000)
#define	gecko_cmd_gatt_server_read_attribute_type_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010A0000)
#define	gecko_cmd_gatt_server_write_attribute_value_id               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020A0000)
#define	gecko_cmd_gatt_server_send_user_read_response_id             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030A0000)
#define	gecko_cmd_gatt_server_send_user_write_response_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040A0000)
#define	gecko_cmd_gatt_server_send_characteristic_notification_id    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050A0000)
#define	gecko_cmd_gatt_server_find_attribute_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060A0000)
#define	gecko_cmd_endpoint_send_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000B0000)
#define	gecko_cmd_endpoint_set_streaming_destination_id              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010B0000)
#define	gecko_cmd_endpoint_close_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020B0000)
#define	gecko_cmd_endpoint_set_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030B0000)
#define	gecko_cmd_endpoint_clr_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040B0000)
#define	gecko_cmd_endpoint_read_counters_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050B0000)
#define	gecko_cmd_hardware_set_soft_timer_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000C0000)
#define	gecko_cmd_hardware_configure_gpio_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010C0000)
#define	gecko_cmd_hardware_write_gpio_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020C0000)
#define	gecko_cmd_hardware_read_gpio_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030C0000)
#define	gecko_cmd_hardware_read_adc_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040C0000)
#define	gecko_cmd_hardware_config_adc_reference_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050C0000)
#define	gecko_cmd_hardware_read_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060C0000)
#define	gecko_cmd_hardware_write_i2c_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070C0000)
#define	gecko_cmd_hardware_stop_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080C0000)
#define	gecko_cmd_hardware_set_uart_configuration_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x090C0000)
#define	gecko_cmd_hardware_read_adc_channel_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0A0C0000)
#define	gecko_cmd_hardware_get_time_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0B0C0000)
#define	gecko_cmd_hardware_set_lazy_soft_timer_id                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0C0C0000)
#define	gecko_cmd_hardware_enable_dcdc_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0D0C0000)
#define	gecko_cmd_flash_ps_dump_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000D0000)
#define	gecko_cmd_flash_ps_erase_all_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010D0000)
#define	gecko_cmd_flash_ps_save_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020D0000)
#define	gecko_cmd_flash_ps_load_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030D0000)
#define	gecko_cmd_flash_ps_erase_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040D0000)
#define	gecko_cmd_test_dtm_tx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000E0000)
#define	gecko_cmd_test_dtm_rx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010E0000)
#define	gecko_cmd_test_dtm_end_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020E0000)
#define	gecko_cmd_sm_set_bondable_mode_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000F0000)
#define	gecko_cmd_sm_configure_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010F0000)
#define	gecko_cmd_sm_store_bonding_configuration_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020F0000)
#define	gecko_cmd_sm_increase_security_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040F0000)
#define	gecko_cmd_sm_delete_bonding_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060F0000)
#define	gecko_cmd_sm_delete_bondings_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070F0000)
#define	gecko_cmd_sm_enter_passkey_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080F0000)
#define	gecko_cmd_sm_set_oob_data_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0A0F0000)
#define	gecko_cmd_sm_list_all_bondings_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0B0F0000)
#define	gecko_cmd_util_atoi_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00110000)
#define	gecko_cmd_util_itoa_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01110000)
#define	gecko_cmd_homekit_configure_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00130000)
#define	gecko_cmd_homekit_advertise_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01130000)
#define	gecko_cmd_homekit_delete_pairings_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02130000)
#define	gecko_cmd_homekit_check_authcp_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03130000)
#define	gecko_cmd_homekit_decrypt_data_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04130000)
#define	gecko_cmd_homekit_encrypt_data_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05130000)
#define	gecko_cmd_homekit_get_pairing_id_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06130000)
#define	gecko_rsp_dfu_reset_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00000000)
#define	gecko_rsp_dfu_flash_set_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01000000)
#define	gecko_rsp_dfu_flash_upload_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02000000)
#define	gecko_rsp_dfu_flash_upload_finish_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03000000)
#define	gecko_rsp_system_hello_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00010000)
#define	gecko_rsp_system_reset_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01010000)
#define	gecko_rsp_system_get_bt_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03010000)
#define	gecko_rsp_system_set_tx_power_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0A010000)
#define	gecko_rsp_system_get_random_data_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0B010000)
#define	gecko_rsp_le_gap_open_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00030000)
#define	gecko_rsp_le_gap_set_mode_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01030000)
#define	gecko_rsp_le_gap_discover_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02030000)
#define	gecko_rsp_le_gap_end_procedure_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03030000)
#define	gecko_rsp_le_gap_set_adv_parameters_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04030000)
#define	gecko_rsp_le_gap_set_conn_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05030000)
#define	gecko_rsp_le_gap_set_scan_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06030000)
#define	gecko_rsp_le_gap_set_adv_data_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07030000)
#define	gecko_rsp_le_gap_set_adv_timeout_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08030000)
#define	gecko_rsp_le_connection_set_parameters_id                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00080000)
#define	gecko_rsp_le_connection_get_rssi_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01080000)
#define	gecko_rsp_le_connection_disable_slave_latency_id             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02080000)
#define	gecko_rsp_gatt_set_max_mtu_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00090000)
#define	gecko_rsp_gatt_discover_primary_services_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01090000)
#define	gecko_rsp_gatt_discover_primary_services_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02090000)
#define	gecko_rsp_gatt_discover_characteristics_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03090000)
#define	gecko_rsp_gatt_discover_characteristics_by_uuid_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04090000)
#define	gecko_rsp_gatt_set_characteristic_notification_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05090000)
#define	gecko_rsp_gatt_discover_descriptors_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06090000)
#define	gecko_rsp_gatt_read_characteristic_value_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07090000)
#define	gecko_rsp_gatt_read_characteristic_value_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08090000)
#define	gecko_rsp_gatt_write_characteristic_value_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09090000)
#define	gecko_rsp_gatt_write_characteristic_value_without_response_id	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0A090000)
#define	gecko_rsp_gatt_prepare_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0B090000)
#define	gecko_rsp_gatt_execute_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0C090000)
#define	gecko_rsp_gatt_send_characteristic_confirmation_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0D090000)
#define	gecko_rsp_gatt_read_descriptor_value_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0E090000)
#define	gecko_rsp_gatt_write_descriptor_value_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0F090000)
#define	gecko_rsp_gatt_find_included_services_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10090000)
#define	gecko_rsp_gatt_read_multiple_characteristic_values_id        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11090000)
#define	gecko_rsp_gatt_server_read_attribute_value_id                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000A0000)
#define	gecko_rsp_gatt_server_read_attribute_type_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010A0000)
#define	gecko_rsp_gatt_server_write_attribute_value_id               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020A0000)
#define	gecko_rsp_gatt_server_send_user_read_response_id             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030A0000)
#define	gecko_rsp_gatt_server_send_user_write_response_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040A0000)
#define	gecko_rsp_gatt_server_send_characteristic_notification_id    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050A0000)
#define	gecko_rsp_gatt_server_find_attribute_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060A0000)
#define	gecko_rsp_endpoint_send_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000B0000)
#define	gecko_rsp_endpoint_set_streaming_destination_id              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010B0000)
#define	gecko_rsp_endpoint_close_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020B0000)
#define	gecko_rsp_endpoint_set_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030B0000)
#define	gecko_rsp_endpoint_clr_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040B0000)
#define	gecko_rsp_endpoint_read_counters_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050B0000)
#define	gecko_rsp_hardware_set_soft_timer_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000C0000)
#define	gecko_rsp_hardware_configure_gpio_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010C0000)
#define	gecko_rsp_hardware_write_gpio_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020C0000)
#define	gecko_rsp_hardware_read_gpio_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030C0000)
#define	gecko_rsp_hardware_read_adc_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040C0000)
#define	gecko_rsp_hardware_config_adc_reference_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050C0000)
#define	gecko_rsp_hardware_read_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060C0000)
#define	gecko_rsp_hardware_write_i2c_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070C0000)
#define	gecko_rsp_hardware_stop_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080C0000)
#define	gecko_rsp_hardware_set_uart_configuration_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x090C0000)
#define	gecko_rsp_hardware_read_adc_channel_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0A0C0000)
#define	gecko_rsp_hardware_get_time_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0B0C0000)
#define	gecko_rsp_hardware_set_lazy_soft_timer_id                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0C0C0000)
#define	gecko_rsp_hardware_enable_dcdc_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0D0C0000)
#define	gecko_rsp_flash_ps_dump_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000D0000)
#define	gecko_rsp_flash_ps_erase_all_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010D0000)
#define	gecko_rsp_flash_ps_save_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020D0000)
#define	gecko_rsp_flash_ps_load_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030D0000)
#define	gecko_rsp_flash_ps_erase_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040D0000)
#define	gecko_rsp_test_dtm_tx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000E0000)
#define	gecko_rsp_test_dtm_rx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010E0000)
#define	gecko_rsp_test_dtm_end_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020E0000)
#define	gecko_rsp_sm_set_bondable_mode_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000F0000)
#define	gecko_rsp_sm_configure_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010F0000)
#define	gecko_rsp_sm_store_bonding_configuration_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020F0000)
#define	gecko_rsp_sm_increase_security_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040F0000)
#define	gecko_rsp_sm_delete_bonding_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060F0000)
#define	gecko_rsp_sm_delete_bondings_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070F0000)
#define	gecko_rsp_sm_enter_passkey_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080F0000)
#define	gecko_rsp_sm_set_oob_data_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0A0F0000)
#define	gecko_rsp_sm_list_all_bondings_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0B0F0000)
#define	gecko_rsp_util_atoi_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00110000)
#define	gecko_rsp_util_itoa_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01110000)
#define	gecko_rsp_homekit_configure_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00130000)
#define	gecko_rsp_homekit_advertise_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01130000)
#define	gecko_rsp_homekit_delete_pairings_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02130000)
#define	gecko_rsp_homekit_check_authcp_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03130000)
#define	gecko_rsp_homekit_decrypt_data_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04130000)
#define	gecko_rsp_homekit_encrypt_data_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05130000)
#define	gecko_rsp_homekit_get_pairing_id_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06130000)
#define	gecko_evt_dfu_boot_id                                        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00000000)
#define	gecko_evt_system_boot_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00010000)
#define	gecko_evt_system_external_signal_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03010000)
#define	gecko_evt_system_awake_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04010000)
#define	gecko_evt_system_hardware_error_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05010000)
#define	gecko_evt_le_gap_scan_response_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00030000)
#define	gecko_evt_le_gap_adv_timeout_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01030000)
#define	gecko_evt_le_connection_opened_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00080000)
#define	gecko_evt_le_connection_closed_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01080000)
#define	gecko_evt_le_connection_parameters_id                        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02080000)
#define	gecko_evt_le_connection_rssi_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03080000)
#define	gecko_evt_gatt_mtu_exchanged_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00090000)
#define	gecko_evt_gatt_service_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01090000)
#define	gecko_evt_gatt_characteristic_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02090000)
#define	gecko_evt_gatt_descriptor_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03090000)
#define	gecko_evt_gatt_characteristic_value_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04090000)
#define	gecko_evt_gatt_descriptor_value_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05090000)
#define	gecko_evt_gatt_procedure_completed_id                        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06090000)
#define	gecko_evt_gatt_server_attribute_value_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000A0000)
#define	gecko_evt_gatt_server_user_read_request_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010A0000)
#define	gecko_evt_gatt_server_user_write_request_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020A0000)
#define	gecko_evt_gatt_server_characteristic_status_id               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030A0000)
#define	gecko_evt_gatt_server_execute_write_completed_id             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040A0000)
#define	gecko_evt_endpoint_syntax_error_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000B0000)
#define	gecko_evt_endpoint_data_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010B0000)
#define	gecko_evt_endpoint_status_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020B0000)
#define	gecko_evt_endpoint_closing_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030B0000)
#define	gecko_evt_hardware_soft_timer_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000C0000)
#define	gecko_evt_hardware_interrupt_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010C0000)
#define	gecko_evt_flash_ps_key_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000D0000)
#define	gecko_evt_test_dtm_completed_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000E0000)
#define	gecko_evt_sm_passkey_display_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000F0000)
#define	gecko_evt_sm_passkey_request_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010F0000)
#define	gecko_evt_sm_bonded_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030F0000)
#define	gecko_evt_sm_bonding_failed_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040F0000)
#define	gecko_evt_sm_list_bonding_entry_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x050F0000)
#define	gecko_evt_sm_list_all_bondings_complete_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x060F0000)
#define	gecko_evt_sm_bonding_request_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x070F0000)
#define	gecko_evt_homekit_setupcode_display_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00130000)
#define	gecko_evt_homekit_paired_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01130000)
#define	gecko_evt_homekit_pair_verified_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02130000)
#define	gecko_evt_homekit_connection_opened_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03130000)
#define	gecko_evt_homekit_connection_closed_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04130000)
#define	gecko_evt_homekit_identify_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05130000)
#include "bg_errorcodes.h"
PACKSTRUCT( struct gecko_msg_dfu_reset_cmd_t
{
	uint8	dfu;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_cmd_t
{
	uint32	address;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_upload_cmd_t
{
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_upload_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_upload_finish_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_dfu_boot_evt_t
{
	uint32	version;
});

PACKSTRUCT( struct gecko_msg_system_hello_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_reset_cmd_t
{
	uint8	dfu;
});

PACKSTRUCT( struct gecko_msg_system_set_max_power_mode_cmd_t
{
	uint8	power_mode;
});

PACKSTRUCT( struct gecko_msg_system_set_max_power_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_get_bt_address_rsp_t
{
	bd_addr	address;
});

PACKSTRUCT( struct gecko_msg_system_set_bt_address_cmd_t
{
	bd_addr	address;
});

PACKSTRUCT( struct gecko_msg_system_set_bt_address_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_get_class_of_device_rsp_t
{
	uint32	cod;
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_set_class_of_device_cmd_t
{
	uint32	cod;
});

PACKSTRUCT( struct gecko_msg_system_set_class_of_device_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_reset_factory_settings_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_set_local_name_cmd_t
{
	uint8array	name;
});

PACKSTRUCT( struct gecko_msg_system_set_local_name_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_get_local_name_rsp_t
{
	uint16	result;
	uint8array	name;
});

PACKSTRUCT( struct gecko_msg_system_set_tx_power_cmd_t
{
	int16	power;
});

PACKSTRUCT( struct gecko_msg_system_set_tx_power_rsp_t
{
	int16	set_power;
});

PACKSTRUCT( struct gecko_msg_system_get_random_data_cmd_t
{
	uint8	length;
});

PACKSTRUCT( struct gecko_msg_system_get_random_data_rsp_t
{
	uint16	result;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_system_boot_evt_t
{
	uint16	major;
	uint16	minor;
	uint16	patch;
	uint16	build;
	uint16	bootloader;
	uint16	hw;
});

PACKSTRUCT( struct gecko_msg_system_initialized_evt_t
{
	bd_addr	address;
});

PACKSTRUCT( struct gecko_msg_system_recovery_evt_t
{
	uint32	id1;
	uint32	id2;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_system_external_signal_evt_t
{
	uint32	extsignals;
});

PACKSTRUCT( struct gecko_msg_system_hardware_error_evt_t
{
	uint16	status;
});

PACKSTRUCT( struct gecko_msg_le_gap_open_cmd_t
{
	bd_addr	address;
	uint8	address_type;
});

PACKSTRUCT( struct gecko_msg_le_gap_open_rsp_t
{
	uint16	result;
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_mode_cmd_t
{
	uint8	discover;
	uint8	connect;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_discover_cmd_t
{
	uint8	mode;
});

PACKSTRUCT( struct gecko_msg_le_gap_discover_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_end_procedure_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_cmd_t
{
	uint16	interval_min;
	uint16	interval_max;
	uint8	channel_map;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_cmd_t
{
	uint16	min_interval;
	uint16	max_interval;
	uint16	latency;
	uint16	timeout;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_cmd_t
{
	uint16	scan_interval;
	uint16	scan_window;
	uint8	active;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_cmd_t
{
	uint8	scan_rsp;
	uint8array	adv_data;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_cmd_t
{
	uint8	intervals;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_scan_response_evt_t
{
	int8	rssi;
	uint8	packet_type;
	bd_addr	address;
	uint8	address_type;
	uint8	bonding;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_cmd_t
{
	uint8	connection;
	uint16	min_interval;
	uint16	max_interval;
	uint16	latency;
	uint16	timeout;
});

PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_cmd_t
{
	uint8	connection;
	uint8	disable;
});

PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_connection_opened_evt_t
{
	bd_addr	address;
	uint8	address_type;
	uint8	master;
	uint8	connection;
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_le_connection_closed_evt_t
{
	uint16	reason;
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_le_connection_parameters_evt_t
{
	uint8	connection;
	uint16	interval;
	uint16	latency;
	uint16	timeout;
	uint8	security_mode;
});

PACKSTRUCT( struct gecko_msg_le_connection_rssi_evt_t
{
	uint8	connection;
	uint8	status;
	int8	rssi;
});

PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_cmd_t
{
	uint16	max_mtu;
});

PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t
{
	uint8	connection;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_cmd_t
{
	uint8	connection;
	uint32	service;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t
{
	uint8	connection;
	uint32	service;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	flags;
});

PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_cmd_t
{
	uint8	connection;
	uint16	characteristic;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_cmd_t
{
	uint8	connection;
	uint16	characteristic;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t
{
	uint8	connection;
	uint32	service;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t
{
	uint8	connection;
	uint8	flags;
});

PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_cmd_t
{
	uint8	connection;
	uint16	descriptor;
});

PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_cmd_t
{
	uint8	connection;
	uint16	descriptor;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_find_included_services_cmd_t
{
	uint8	connection;
	uint32	service;
});

PACKSTRUCT( struct gecko_msg_gatt_find_included_services_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t
{
	uint8	connection;
	uint8array	characteristic_list;
});

PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_mtu_exchanged_evt_t
{
	uint8	connection;
	uint16	mtu;
});

PACKSTRUCT( struct gecko_msg_gatt_service_evt_t
{
	uint8	connection;
	uint32	service;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_characteristic_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	properties;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_descriptor_evt_t
{
	uint8	connection;
	uint16	descriptor;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_characteristic_value_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_opcode;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_descriptor_value_evt_t
{
	uint8	connection;
	uint16	descriptor;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_procedure_completed_evt_t
{
	uint8	connection;
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_cmd_t
{
	uint16	attribute;
	uint16	offset;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_rsp_t
{
	uint16	result;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_cmd_t
{
	uint16	attribute;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_rsp_t
{
	uint16	result;
	uint8array	type;
});

PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_cmd_t
{
	uint16	attribute;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_errorcode;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_errorcode;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_cmd_t
{
	uint16	start;
	uint8array	type;
});

PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_rsp_t
{
	uint16	result;
	uint16	attribute;
});

PACKSTRUCT( struct gecko_msg_gatt_server_attribute_value_evt_t
{
	uint8	connection;
	uint16	attribute;
	uint8	att_opcode;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_user_read_request_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_opcode;
	uint16	offset;
});

PACKSTRUCT( struct gecko_msg_gatt_server_user_write_request_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_opcode;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_characteristic_status_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	status_flags;
	uint16	client_config_flags;
});

PACKSTRUCT( struct gecko_msg_gatt_server_execute_write_completed_evt_t
{
	uint8	connection;
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_endpoint_send_cmd_t
{
	uint8	endpoint;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_endpoint_send_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_streaming_destination_cmd_t
{
	uint8	endpoint;
	uint8	destination_endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_streaming_destination_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_close_cmd_t
{
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_close_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_flags_cmd_t
{
	uint8	endpoint;
	uint32	flags;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_flags_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_clr_flags_cmd_t
{
	uint8	endpoint;
	uint32	flags;
});

PACKSTRUCT( struct gecko_msg_endpoint_clr_flags_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_read_counters_cmd_t
{
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_read_counters_rsp_t
{
	uint16	result;
	uint8	endpoint;
	uint32	tx;
	uint32	rx;
});

PACKSTRUCT( struct gecko_msg_endpoint_syntax_error_evt_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_data_evt_t
{
	uint8	endpoint;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_endpoint_status_evt_t
{
	uint8	endpoint;
	uint32	type;
	int8	destination_endpoint;
	uint8	flags;
});

PACKSTRUCT( struct gecko_msg_endpoint_closing_evt_t
{
	uint16	reason;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_cmd_t
{
	uint32	time;
	uint8	handle;
	uint8	single_shot;
});

PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_configure_gpio_cmd_t
{
	uint8	port;
	uint8	gpio;
	uint8	mode;
	uint8	output;
});

PACKSTRUCT( struct gecko_msg_hardware_configure_gpio_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_write_gpio_cmd_t
{
	uint8	port;
	uint16	mask;
	uint16	data;
});

PACKSTRUCT( struct gecko_msg_hardware_write_gpio_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_read_gpio_cmd_t
{
	uint8	port;
	uint16	mask;
});

PACKSTRUCT( struct gecko_msg_hardware_read_gpio_rsp_t
{
	uint16	result;
	uint16	data;
});

PACKSTRUCT( struct gecko_msg_hardware_read_adc_cmd_t
{
	uint8	port;
	uint8	pin;
});

PACKSTRUCT( struct gecko_msg_hardware_read_adc_rsp_t
{
	uint16	result;
	uint16	value;
});

PACKSTRUCT( struct gecko_msg_hardware_config_adc_reference_cmd_t
{
	uint8	reference;
});

PACKSTRUCT( struct gecko_msg_hardware_config_adc_reference_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_read_i2c_cmd_t
{
	uint8	channel;
	uint16	slave_address;
	uint8	length;
});

PACKSTRUCT( struct gecko_msg_hardware_read_i2c_rsp_t
{
	uint16	result;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_hardware_write_i2c_cmd_t
{
	uint8	channel;
	uint16	slave_address;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_hardware_write_i2c_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_stop_i2c_cmd_t
{
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_hardware_stop_i2c_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_set_uart_configuration_cmd_t
{
	uint8	index;
	uint32	baud_rate;
	uint8	data_bits;
	uint8	stop_bits;
	uint8	parity;
	uint8	flow_ctrl;
});

PACKSTRUCT( struct gecko_msg_hardware_set_uart_configuration_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_read_adc_channel_cmd_t
{
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_hardware_read_adc_channel_rsp_t
{
	uint16	result;
	uint16	value;
});

PACKSTRUCT( struct gecko_msg_hardware_get_time_rsp_t
{
	uint32	seconds;
	uint16	ticks;
});

PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t
{
	uint32	time;
	uint32	slack;
	uint8	handle;
	uint8	single_shot;
});

PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_enable_dcdc_cmd_t
{
	uint8	enable;
});

PACKSTRUCT( struct gecko_msg_hardware_enable_dcdc_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_soft_timer_evt_t
{
	uint8	handle;
});

PACKSTRUCT( struct gecko_msg_hardware_interrupt_evt_t
{
	uint32	interrupts;
	uint32	timestamp;
});

PACKSTRUCT( struct gecko_msg_flash_ps_dump_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_erase_all_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_save_cmd_t
{
	uint16	key;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_flash_ps_save_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_load_cmd_t
{
	uint16	key;
});

PACKSTRUCT( struct gecko_msg_flash_ps_load_rsp_t
{
	uint16	result;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_flash_ps_erase_cmd_t
{
	uint16	key;
});

PACKSTRUCT( struct gecko_msg_flash_ps_erase_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_key_evt_t
{
	uint16	key;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_test_dtm_tx_cmd_t
{
	uint8	packet_type;
	uint8	length;
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_test_dtm_tx_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_dtm_rx_cmd_t
{
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_test_dtm_rx_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_dtm_end_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_tx_test_cmd_t
{
	uint8	modulation;
	uint8	channel;
	uint8	power;
});

PACKSTRUCT( struct gecko_msg_test_tx_test_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_debug_enable_cmd_t
{
	uint8	id;
	uint8	enable;
});

PACKSTRUCT( struct gecko_msg_test_ssp_debug_cmd_t
{
	uint8	enable;
});

PACKSTRUCT( struct gecko_msg_test_debug_command_cmd_t
{
	uint8	id;
	uint8array	debugdata;
});

PACKSTRUCT( struct gecko_msg_test_debug_command_rsp_t
{
	uint16	result;
	uint8	id;
	uint8array	debugdata;
});

PACKSTRUCT( struct gecko_msg_test_device_under_test_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_pts_msc_cmd_t
{
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_test_pts_msc_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_rx_test_cmd_t
{
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_test_rx_test_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_packet_test_cmd_t
{
	uint8	mode;
	uint8	tx_freq;
	uint8	rx_freq;
	uint8	acl_type;
	uint16	acl_len;
	uint8	power;
	uint8	disable_whitening;
});

PACKSTRUCT( struct gecko_msg_test_packet_test_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_debug_counter_cmd_t
{
	uint32	id;
});

PACKSTRUCT( struct gecko_msg_test_debug_counter_rsp_t
{
	uint16	result;
	uint32	value;
});

PACKSTRUCT( struct gecko_msg_test_get_controller_version_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_dtm_completed_evt_t
{
	uint16	result;
	uint16	number_of_packets;
});

PACKSTRUCT( struct gecko_msg_test_debug_evt_t
{
	uint16	id;
	uint16	u32;
	uint8array	stuff;
});

PACKSTRUCT( struct gecko_msg_test_hcidump_evt_t
{
	uint32	time;
	uint8	direction;
	uint8	packet_type;
	uint16array	data;
});

PACKSTRUCT( struct gecko_msg_test_error_evt_t
{
	uint16	param1;
	uint8array	param2;
});

PACKSTRUCT( struct gecko_msg_test_controller_version_evt_t
{
	uint8	hci_version;
	uint16	hci_revision;
	uint8	lmp_version;
	uint16	Manufacturer;
	uint16	lmp_subversion;
});

PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_cmd_t
{
	uint8	bondable;
});

PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_configure_cmd_t
{
	uint8	flags;
	uint8	io_capabilities;
});

PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_cmd_t
{
	uint8	max_bonding_count;
	uint8	policy_flags;
});

PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_read_bonding_configuration_rsp_t
{
	uint8	max_bonding_count;
	uint8	policy_flags;
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_increase_security_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_sm_increase_security_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_read_bonding_cmd_t
{
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_sm_read_bonding_rsp_t
{
	uint16	result;
	bd_addr	address;
	uint8	address_type;
	uint8array	bonding_key;
});

PACKSTRUCT( struct gecko_msg_sm_delete_bonding_cmd_t
{
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_sm_delete_bonding_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_delete_bondings_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_enter_passkey_cmd_t
{
	uint8	connection;
	uint32	passkey;
});

PACKSTRUCT( struct gecko_msg_sm_enter_passkey_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_cmd_t
{
	uint8	connection;
	uint8	confirm;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_set_oob_data_cmd_t
{
	uint8array	oob_data;
});

PACKSTRUCT( struct gecko_msg_sm_set_oob_data_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_list_all_bondings_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_confirm_bonding_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_enter_pin_code_cmd_t
{
	bd_addr	address;
	uint8array	pin_code;
});

PACKSTRUCT( struct gecko_msg_sm_enter_pin_code_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_display_evt_t
{
	uint8	connection;
	uint32	passkey;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_request_evt_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_sm_confirm_passkey_evt_t
{
	uint8	connection;
	uint32	passkey;
});

PACKSTRUCT( struct gecko_msg_sm_bonded_evt_t
{
	uint8	connection;
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_sm_bonding_failed_evt_t
{
	uint8	connection;
	uint16	reason;
});

PACKSTRUCT( struct gecko_msg_sm_list_bonding_entry_evt_t
{
	uint8	bonding;
	bd_addr	address;
	uint8	address_type;
});

PACKSTRUCT( struct gecko_msg_sm_bonding_request_evt_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_sm_pin_code_request_evt_t
{
	bd_addr	address;
});

PACKSTRUCT( struct gecko_msg_util_atoi_cmd_t
{
	uint8array	string;
});

PACKSTRUCT( struct gecko_msg_util_atoi_rsp_t
{
	int32	value;
});

PACKSTRUCT( struct gecko_msg_util_itoa_cmd_t
{
	int32	value;
});

PACKSTRUCT( struct gecko_msg_util_itoa_rsp_t
{
	uint8array	string;
});

PACKSTRUCT( struct gecko_msg_homekit_configure_cmd_t
{
	uint8	i2c_address;
	uint8	support_display;
	uint8	hap_features;
});

PACKSTRUCT( struct gecko_msg_homekit_configure_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_homekit_advertise_cmd_t
{
	uint8	enable;
	uint16	category;
});

PACKSTRUCT( struct gecko_msg_homekit_advertise_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_homekit_delete_pairings_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_homekit_check_authcp_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_homekit_decrypt_data_cmd_t
{
	uint8	connection;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_homekit_decrypt_data_rsp_t
{
	uint16	result;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_homekit_encrypt_data_cmd_t
{
	uint8	connection;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_homekit_encrypt_data_rsp_t
{
	uint16	result;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_rsp_t
{
	uint16	result;
	uint8array	pairing_id;
});

PACKSTRUCT( struct gecko_msg_homekit_setupcode_display_evt_t
{
	uint8	connection;
	uint8array	setupcode;
});

PACKSTRUCT( struct gecko_msg_homekit_paired_evt_t
{
	uint8	connection;
	uint16	reason;
});

PACKSTRUCT( struct gecko_msg_homekit_pair_verified_evt_t
{
	uint8	connection;
	uint16	reason;
});

PACKSTRUCT( struct gecko_msg_homekit_connection_opened_evt_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_homekit_connection_closed_evt_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_homekit_identify_evt_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_cmd_packet
{
	uint32   header;

union{
	uint8 handle;

	struct gecko_msg_dfu_reset_cmd_t                                        cmd_dfu_reset;
	struct gecko_msg_dfu_flash_set_address_cmd_t                            cmd_dfu_flash_set_address;
	struct gecko_msg_dfu_flash_upload_cmd_t                                 cmd_dfu_flash_upload;
	struct gecko_msg_dfu_boot_evt_t                                         evt_dfu_boot;
	struct gecko_msg_dfu_flash_set_address_rsp_t                            rsp_dfu_flash_set_address;
	struct gecko_msg_dfu_flash_upload_rsp_t                                 rsp_dfu_flash_upload;
	struct gecko_msg_dfu_flash_upload_finish_rsp_t                          rsp_dfu_flash_upload_finish;
	struct gecko_msg_system_reset_cmd_t                                     cmd_system_reset;
	struct gecko_msg_system_set_max_power_mode_cmd_t                        cmd_system_set_max_power_mode;
	struct gecko_msg_system_set_bt_address_cmd_t                            cmd_system_set_bt_address;
	struct gecko_msg_system_set_class_of_device_cmd_t                       cmd_system_set_class_of_device;
	struct gecko_msg_system_set_local_name_cmd_t                            cmd_system_set_local_name;
	struct gecko_msg_system_set_tx_power_cmd_t                              cmd_system_set_tx_power;
	struct gecko_msg_system_get_random_data_cmd_t                           cmd_system_get_random_data;
	struct gecko_msg_system_boot_evt_t                                      evt_system_boot;
	struct gecko_msg_system_initialized_evt_t                               evt_system_initialized;
	struct gecko_msg_system_recovery_evt_t                                  evt_system_recovery;
	struct gecko_msg_system_external_signal_evt_t                           evt_system_external_signal;
	struct gecko_msg_system_hardware_error_evt_t                            evt_system_hardware_error;
	struct gecko_msg_system_hello_rsp_t                                     rsp_system_hello;
	struct gecko_msg_system_set_max_power_mode_rsp_t                        rsp_system_set_max_power_mode;
	struct gecko_msg_system_get_bt_address_rsp_t                            rsp_system_get_bt_address;
	struct gecko_msg_system_set_bt_address_rsp_t                            rsp_system_set_bt_address;
	struct gecko_msg_system_get_class_of_device_rsp_t                       rsp_system_get_class_of_device;
	struct gecko_msg_system_set_class_of_device_rsp_t                       rsp_system_set_class_of_device;
	struct gecko_msg_system_reset_factory_settings_rsp_t                    rsp_system_reset_factory_settings;
	struct gecko_msg_system_set_local_name_rsp_t                            rsp_system_set_local_name;
	struct gecko_msg_system_get_local_name_rsp_t                            rsp_system_get_local_name;
	struct gecko_msg_system_set_tx_power_rsp_t                              rsp_system_set_tx_power;
	struct gecko_msg_system_get_random_data_rsp_t                           rsp_system_get_random_data;
	struct gecko_msg_le_gap_open_cmd_t                                      cmd_le_gap_open;
	struct gecko_msg_le_gap_set_mode_cmd_t                                  cmd_le_gap_set_mode;
	struct gecko_msg_le_gap_discover_cmd_t                                  cmd_le_gap_discover;
	struct gecko_msg_le_gap_set_adv_parameters_cmd_t                        cmd_le_gap_set_adv_parameters;
	struct gecko_msg_le_gap_set_conn_parameters_cmd_t                       cmd_le_gap_set_conn_parameters;
	struct gecko_msg_le_gap_set_scan_parameters_cmd_t                       cmd_le_gap_set_scan_parameters;
	struct gecko_msg_le_gap_set_adv_data_cmd_t                              cmd_le_gap_set_adv_data;
	struct gecko_msg_le_gap_set_adv_timeout_cmd_t                           cmd_le_gap_set_adv_timeout;
	struct gecko_msg_le_gap_scan_response_evt_t                             evt_le_gap_scan_response;
	struct gecko_msg_le_gap_open_rsp_t                                      rsp_le_gap_open;
	struct gecko_msg_le_gap_set_mode_rsp_t                                  rsp_le_gap_set_mode;
	struct gecko_msg_le_gap_discover_rsp_t                                  rsp_le_gap_discover;
	struct gecko_msg_le_gap_end_procedure_rsp_t                             rsp_le_gap_end_procedure;
	struct gecko_msg_le_gap_set_adv_parameters_rsp_t                        rsp_le_gap_set_adv_parameters;
	struct gecko_msg_le_gap_set_conn_parameters_rsp_t                       rsp_le_gap_set_conn_parameters;
	struct gecko_msg_le_gap_set_scan_parameters_rsp_t                       rsp_le_gap_set_scan_parameters;
	struct gecko_msg_le_gap_set_adv_data_rsp_t                              rsp_le_gap_set_adv_data;
	struct gecko_msg_le_gap_set_adv_timeout_rsp_t                           rsp_le_gap_set_adv_timeout;
	struct gecko_msg_le_connection_set_parameters_cmd_t                     cmd_le_connection_set_parameters;
	struct gecko_msg_le_connection_get_rssi_cmd_t                           cmd_le_connection_get_rssi;
	struct gecko_msg_le_connection_disable_slave_latency_cmd_t              cmd_le_connection_disable_slave_latency;
	struct gecko_msg_le_connection_opened_evt_t                             evt_le_connection_opened;
	struct gecko_msg_le_connection_closed_evt_t                             evt_le_connection_closed;
	struct gecko_msg_le_connection_parameters_evt_t                         evt_le_connection_parameters;
	struct gecko_msg_le_connection_rssi_evt_t                               evt_le_connection_rssi;
	struct gecko_msg_le_connection_set_parameters_rsp_t                     rsp_le_connection_set_parameters;
	struct gecko_msg_le_connection_get_rssi_rsp_t                           rsp_le_connection_get_rssi;
	struct gecko_msg_le_connection_disable_slave_latency_rsp_t              rsp_le_connection_disable_slave_latency;
	struct gecko_msg_gatt_set_max_mtu_cmd_t                                 cmd_gatt_set_max_mtu;
	struct gecko_msg_gatt_discover_primary_services_cmd_t                   cmd_gatt_discover_primary_services;
	struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t           cmd_gatt_discover_primary_services_by_uuid;
	struct gecko_msg_gatt_discover_characteristics_cmd_t                    cmd_gatt_discover_characteristics;
	struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t            cmd_gatt_discover_characteristics_by_uuid;
	struct gecko_msg_gatt_set_characteristic_notification_cmd_t             cmd_gatt_set_characteristic_notification;
	struct gecko_msg_gatt_discover_descriptors_cmd_t                        cmd_gatt_discover_descriptors;
	struct gecko_msg_gatt_read_characteristic_value_cmd_t                   cmd_gatt_read_characteristic_value;
	struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t           cmd_gatt_read_characteristic_value_by_uuid;
	struct gecko_msg_gatt_write_characteristic_value_cmd_t                  cmd_gatt_write_characteristic_value;
	struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t cmd_gatt_write_characteristic_value_without_response;
	struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t          cmd_gatt_prepare_characteristic_value_write;
	struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t          cmd_gatt_execute_characteristic_value_write;
	struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t            cmd_gatt_send_characteristic_confirmation;
	struct gecko_msg_gatt_read_descriptor_value_cmd_t                       cmd_gatt_read_descriptor_value;
	struct gecko_msg_gatt_write_descriptor_value_cmd_t                      cmd_gatt_write_descriptor_value;
	struct gecko_msg_gatt_find_included_services_cmd_t                      cmd_gatt_find_included_services;
	struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t         cmd_gatt_read_multiple_characteristic_values;
	struct gecko_msg_gatt_mtu_exchanged_evt_t                               evt_gatt_mtu_exchanged;
	struct gecko_msg_gatt_service_evt_t                                     evt_gatt_service;
	struct gecko_msg_gatt_characteristic_evt_t                              evt_gatt_characteristic;
	struct gecko_msg_gatt_descriptor_evt_t                                  evt_gatt_descriptor;
	struct gecko_msg_gatt_characteristic_value_evt_t                        evt_gatt_characteristic_value;
	struct gecko_msg_gatt_descriptor_value_evt_t                            evt_gatt_descriptor_value;
	struct gecko_msg_gatt_procedure_completed_evt_t                         evt_gatt_procedure_completed;
	struct gecko_msg_gatt_set_max_mtu_rsp_t                                 rsp_gatt_set_max_mtu;
	struct gecko_msg_gatt_discover_primary_services_rsp_t                   rsp_gatt_discover_primary_services;
	struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t           rsp_gatt_discover_primary_services_by_uuid;
	struct gecko_msg_gatt_discover_characteristics_rsp_t                    rsp_gatt_discover_characteristics;
	struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t            rsp_gatt_discover_characteristics_by_uuid;
	struct gecko_msg_gatt_set_characteristic_notification_rsp_t             rsp_gatt_set_characteristic_notification;
	struct gecko_msg_gatt_discover_descriptors_rsp_t                        rsp_gatt_discover_descriptors;
	struct gecko_msg_gatt_read_characteristic_value_rsp_t                   rsp_gatt_read_characteristic_value;
	struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t           rsp_gatt_read_characteristic_value_by_uuid;
	struct gecko_msg_gatt_write_characteristic_value_rsp_t                  rsp_gatt_write_characteristic_value;
	struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t rsp_gatt_write_characteristic_value_without_response;
	struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t          rsp_gatt_prepare_characteristic_value_write;
	struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t          rsp_gatt_execute_characteristic_value_write;
	struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t            rsp_gatt_send_characteristic_confirmation;
	struct gecko_msg_gatt_read_descriptor_value_rsp_t                       rsp_gatt_read_descriptor_value;
	struct gecko_msg_gatt_write_descriptor_value_rsp_t                      rsp_gatt_write_descriptor_value;
	struct gecko_msg_gatt_find_included_services_rsp_t                      rsp_gatt_find_included_services;
	struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t         rsp_gatt_read_multiple_characteristic_values;
	struct gecko_msg_gatt_server_read_attribute_value_cmd_t                 cmd_gatt_server_read_attribute_value;
	struct gecko_msg_gatt_server_read_attribute_type_cmd_t                  cmd_gatt_server_read_attribute_type;
	struct gecko_msg_gatt_server_write_attribute_value_cmd_t                cmd_gatt_server_write_attribute_value;
	struct gecko_msg_gatt_server_send_user_read_response_cmd_t              cmd_gatt_server_send_user_read_response;
	struct gecko_msg_gatt_server_send_user_write_response_cmd_t             cmd_gatt_server_send_user_write_response;
	struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t     cmd_gatt_server_send_characteristic_notification;
	struct gecko_msg_gatt_server_find_attribute_cmd_t                       cmd_gatt_server_find_attribute;
	struct gecko_msg_gatt_server_attribute_value_evt_t                      evt_gatt_server_attribute_value;
	struct gecko_msg_gatt_server_user_read_request_evt_t                    evt_gatt_server_user_read_request;
	struct gecko_msg_gatt_server_user_write_request_evt_t                   evt_gatt_server_user_write_request;
	struct gecko_msg_gatt_server_characteristic_status_evt_t                evt_gatt_server_characteristic_status;
	struct gecko_msg_gatt_server_execute_write_completed_evt_t              evt_gatt_server_execute_write_completed;
	struct gecko_msg_gatt_server_read_attribute_value_rsp_t                 rsp_gatt_server_read_attribute_value;
	struct gecko_msg_gatt_server_read_attribute_type_rsp_t                  rsp_gatt_server_read_attribute_type;
	struct gecko_msg_gatt_server_write_attribute_value_rsp_t                rsp_gatt_server_write_attribute_value;
	struct gecko_msg_gatt_server_send_user_read_response_rsp_t              rsp_gatt_server_send_user_read_response;
	struct gecko_msg_gatt_server_send_user_write_response_rsp_t             rsp_gatt_server_send_user_write_response;
	struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t     rsp_gatt_server_send_characteristic_notification;
	struct gecko_msg_gatt_server_find_attribute_rsp_t                       rsp_gatt_server_find_attribute;
	struct gecko_msg_endpoint_send_cmd_t                                    cmd_endpoint_send;
	struct gecko_msg_endpoint_set_streaming_destination_cmd_t               cmd_endpoint_set_streaming_destination;
	struct gecko_msg_endpoint_close_cmd_t                                   cmd_endpoint_close;
	struct gecko_msg_endpoint_set_flags_cmd_t                               cmd_endpoint_set_flags;
	struct gecko_msg_endpoint_clr_flags_cmd_t                               cmd_endpoint_clr_flags;
	struct gecko_msg_endpoint_read_counters_cmd_t                           cmd_endpoint_read_counters;
	struct gecko_msg_endpoint_syntax_error_evt_t                            evt_endpoint_syntax_error;
	struct gecko_msg_endpoint_data_evt_t                                    evt_endpoint_data;
	struct gecko_msg_endpoint_status_evt_t                                  evt_endpoint_status;
	struct gecko_msg_endpoint_closing_evt_t                                 evt_endpoint_closing;
	struct gecko_msg_endpoint_send_rsp_t                                    rsp_endpoint_send;
	struct gecko_msg_endpoint_set_streaming_destination_rsp_t               rsp_endpoint_set_streaming_destination;
	struct gecko_msg_endpoint_close_rsp_t                                   rsp_endpoint_close;
	struct gecko_msg_endpoint_set_flags_rsp_t                               rsp_endpoint_set_flags;
	struct gecko_msg_endpoint_clr_flags_rsp_t                               rsp_endpoint_clr_flags;
	struct gecko_msg_endpoint_read_counters_rsp_t                           rsp_endpoint_read_counters;
	struct gecko_msg_hardware_set_soft_timer_cmd_t                          cmd_hardware_set_soft_timer;
	struct gecko_msg_hardware_configure_gpio_cmd_t                          cmd_hardware_configure_gpio;
	struct gecko_msg_hardware_write_gpio_cmd_t                              cmd_hardware_write_gpio;
	struct gecko_msg_hardware_read_gpio_cmd_t                               cmd_hardware_read_gpio;
	struct gecko_msg_hardware_read_adc_cmd_t                                cmd_hardware_read_adc;
	struct gecko_msg_hardware_config_adc_reference_cmd_t                    cmd_hardware_config_adc_reference;
	struct gecko_msg_hardware_read_i2c_cmd_t                                cmd_hardware_read_i2c;
	struct gecko_msg_hardware_write_i2c_cmd_t                               cmd_hardware_write_i2c;
	struct gecko_msg_hardware_stop_i2c_cmd_t                                cmd_hardware_stop_i2c;
	struct gecko_msg_hardware_set_uart_configuration_cmd_t                  cmd_hardware_set_uart_configuration;
	struct gecko_msg_hardware_read_adc_channel_cmd_t                        cmd_hardware_read_adc_channel;
	struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t                     cmd_hardware_set_lazy_soft_timer;
	struct gecko_msg_hardware_enable_dcdc_cmd_t                             cmd_hardware_enable_dcdc;
	struct gecko_msg_hardware_soft_timer_evt_t                              evt_hardware_soft_timer;
	struct gecko_msg_hardware_interrupt_evt_t                               evt_hardware_interrupt;
	struct gecko_msg_hardware_set_soft_timer_rsp_t                          rsp_hardware_set_soft_timer;
	struct gecko_msg_hardware_configure_gpio_rsp_t                          rsp_hardware_configure_gpio;
	struct gecko_msg_hardware_write_gpio_rsp_t                              rsp_hardware_write_gpio;
	struct gecko_msg_hardware_read_gpio_rsp_t                               rsp_hardware_read_gpio;
	struct gecko_msg_hardware_read_adc_rsp_t                                rsp_hardware_read_adc;
	struct gecko_msg_hardware_config_adc_reference_rsp_t                    rsp_hardware_config_adc_reference;
	struct gecko_msg_hardware_read_i2c_rsp_t                                rsp_hardware_read_i2c;
	struct gecko_msg_hardware_write_i2c_rsp_t                               rsp_hardware_write_i2c;
	struct gecko_msg_hardware_stop_i2c_rsp_t                                rsp_hardware_stop_i2c;
	struct gecko_msg_hardware_set_uart_configuration_rsp_t                  rsp_hardware_set_uart_configuration;
	struct gecko_msg_hardware_read_adc_channel_rsp_t                        rsp_hardware_read_adc_channel;
	struct gecko_msg_hardware_get_time_rsp_t                                rsp_hardware_get_time;
	struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t                     rsp_hardware_set_lazy_soft_timer;
	struct gecko_msg_hardware_enable_dcdc_rsp_t                             rsp_hardware_enable_dcdc;
	struct gecko_msg_flash_ps_save_cmd_t                                    cmd_flash_ps_save;
	struct gecko_msg_flash_ps_load_cmd_t                                    cmd_flash_ps_load;
	struct gecko_msg_flash_ps_erase_cmd_t                                   cmd_flash_ps_erase;
	struct gecko_msg_flash_ps_key_evt_t                                     evt_flash_ps_key;
	struct gecko_msg_flash_ps_dump_rsp_t                                    rsp_flash_ps_dump;
	struct gecko_msg_flash_ps_erase_all_rsp_t                               rsp_flash_ps_erase_all;
	struct gecko_msg_flash_ps_save_rsp_t                                    rsp_flash_ps_save;
	struct gecko_msg_flash_ps_load_rsp_t                                    rsp_flash_ps_load;
	struct gecko_msg_flash_ps_erase_rsp_t                                   rsp_flash_ps_erase;
	struct gecko_msg_test_dtm_tx_cmd_t                                      cmd_test_dtm_tx;
	struct gecko_msg_test_dtm_rx_cmd_t                                      cmd_test_dtm_rx;
	struct gecko_msg_test_tx_test_cmd_t                                     cmd_test_tx_test;
	struct gecko_msg_test_debug_enable_cmd_t                                cmd_test_debug_enable;
	struct gecko_msg_test_ssp_debug_cmd_t                                   cmd_test_ssp_debug;
	struct gecko_msg_test_debug_command_cmd_t                               cmd_test_debug_command;
	struct gecko_msg_test_pts_msc_cmd_t                                     cmd_test_pts_msc;
	struct gecko_msg_test_rx_test_cmd_t                                     cmd_test_rx_test;
	struct gecko_msg_test_packet_test_cmd_t                                 cmd_test_packet_test;
	struct gecko_msg_test_debug_counter_cmd_t                               cmd_test_debug_counter;
	struct gecko_msg_test_dtm_completed_evt_t                               evt_test_dtm_completed;
	struct gecko_msg_test_debug_evt_t                                       evt_test_debug;
	struct gecko_msg_test_hcidump_evt_t                                     evt_test_hcidump;
	struct gecko_msg_test_error_evt_t                                       evt_test_error;
	struct gecko_msg_test_controller_version_evt_t                          evt_test_controller_version;
	struct gecko_msg_test_dtm_tx_rsp_t                                      rsp_test_dtm_tx;
	struct gecko_msg_test_dtm_rx_rsp_t                                      rsp_test_dtm_rx;
	struct gecko_msg_test_dtm_end_rsp_t                                     rsp_test_dtm_end;
	struct gecko_msg_test_tx_test_rsp_t                                     rsp_test_tx_test;
	struct gecko_msg_test_debug_command_rsp_t                               rsp_test_debug_command;
	struct gecko_msg_test_device_under_test_mode_rsp_t                      rsp_test_device_under_test_mode;
	struct gecko_msg_test_pts_msc_rsp_t                                     rsp_test_pts_msc;
	struct gecko_msg_test_rx_test_rsp_t                                     rsp_test_rx_test;
	struct gecko_msg_test_packet_test_rsp_t                                 rsp_test_packet_test;
	struct gecko_msg_test_debug_counter_rsp_t                               rsp_test_debug_counter;
	struct gecko_msg_test_get_controller_version_rsp_t                      rsp_test_get_controller_version;
	struct gecko_msg_sm_set_bondable_mode_cmd_t                             cmd_sm_set_bondable_mode;
	struct gecko_msg_sm_configure_cmd_t                                     cmd_sm_configure;
	struct gecko_msg_sm_store_bonding_configuration_cmd_t                   cmd_sm_store_bonding_configuration;
	struct gecko_msg_sm_increase_security_cmd_t                             cmd_sm_increase_security;
	struct gecko_msg_sm_read_bonding_cmd_t                                  cmd_sm_read_bonding;
	struct gecko_msg_sm_delete_bonding_cmd_t                                cmd_sm_delete_bonding;
	struct gecko_msg_sm_enter_passkey_cmd_t                                 cmd_sm_enter_passkey;
	struct gecko_msg_sm_passkey_confirm_cmd_t                               cmd_sm_passkey_confirm;
	struct gecko_msg_sm_set_oob_data_cmd_t                                  cmd_sm_set_oob_data;
	struct gecko_msg_sm_enter_pin_code_cmd_t                                cmd_sm_enter_pin_code;
	struct gecko_msg_sm_passkey_display_evt_t                               evt_sm_passkey_display;
	struct gecko_msg_sm_passkey_request_evt_t                               evt_sm_passkey_request;
	struct gecko_msg_sm_confirm_passkey_evt_t                               evt_sm_confirm_passkey;
	struct gecko_msg_sm_bonded_evt_t                                        evt_sm_bonded;
	struct gecko_msg_sm_bonding_failed_evt_t                                evt_sm_bonding_failed;
	struct gecko_msg_sm_list_bonding_entry_evt_t                            evt_sm_list_bonding_entry;
	struct gecko_msg_sm_bonding_request_evt_t                               evt_sm_bonding_request;
	struct gecko_msg_sm_pin_code_request_evt_t                              evt_sm_pin_code_request;
	struct gecko_msg_sm_set_bondable_mode_rsp_t                             rsp_sm_set_bondable_mode;
	struct gecko_msg_sm_store_bonding_configuration_rsp_t                   rsp_sm_store_bonding_configuration;
	struct gecko_msg_sm_read_bonding_configuration_rsp_t                    rsp_sm_read_bonding_configuration;
	struct gecko_msg_sm_increase_security_rsp_t                             rsp_sm_increase_security;
	struct gecko_msg_sm_read_bonding_rsp_t                                  rsp_sm_read_bonding;
	struct gecko_msg_sm_delete_bonding_rsp_t                                rsp_sm_delete_bonding;
	struct gecko_msg_sm_delete_bondings_rsp_t                               rsp_sm_delete_bondings;
	struct gecko_msg_sm_enter_passkey_rsp_t                                 rsp_sm_enter_passkey;
	struct gecko_msg_sm_passkey_confirm_rsp_t                               rsp_sm_passkey_confirm;
	struct gecko_msg_sm_set_oob_data_rsp_t                                  rsp_sm_set_oob_data;
	struct gecko_msg_sm_list_all_bondings_rsp_t                             rsp_sm_list_all_bondings;
	struct gecko_msg_sm_confirm_bonding_rsp_t                               rsp_sm_confirm_bonding;
	struct gecko_msg_sm_enter_pin_code_rsp_t                                rsp_sm_enter_pin_code;
	struct gecko_msg_util_atoi_cmd_t                                        cmd_util_atoi;
	struct gecko_msg_util_itoa_cmd_t                                        cmd_util_itoa;
	struct gecko_msg_util_atoi_rsp_t                                        rsp_util_atoi;
	struct gecko_msg_util_itoa_rsp_t                                        rsp_util_itoa;
	struct gecko_msg_homekit_configure_cmd_t                                cmd_homekit_configure;
	struct gecko_msg_homekit_advertise_cmd_t                                cmd_homekit_advertise;
	struct gecko_msg_homekit_decrypt_data_cmd_t                             cmd_homekit_decrypt_data;
	struct gecko_msg_homekit_encrypt_data_cmd_t                             cmd_homekit_encrypt_data;
	struct gecko_msg_homekit_get_pairing_id_cmd_t                           cmd_homekit_get_pairing_id;
	struct gecko_msg_homekit_setupcode_display_evt_t                        evt_homekit_setupcode_display;
	struct gecko_msg_homekit_paired_evt_t                                   evt_homekit_paired;
	struct gecko_msg_homekit_pair_verified_evt_t                            evt_homekit_pair_verified;
	struct gecko_msg_homekit_connection_opened_evt_t                        evt_homekit_connection_opened;
	struct gecko_msg_homekit_connection_closed_evt_t                        evt_homekit_connection_closed;
	struct gecko_msg_homekit_identify_evt_t                                 evt_homekit_identify;
	struct gecko_msg_homekit_configure_rsp_t                                rsp_homekit_configure;
	struct gecko_msg_homekit_advertise_rsp_t                                rsp_homekit_advertise;
	struct gecko_msg_homekit_delete_pairings_rsp_t                          rsp_homekit_delete_pairings;
	struct gecko_msg_homekit_check_authcp_rsp_t                             rsp_homekit_check_authcp;
	struct gecko_msg_homekit_decrypt_data_rsp_t                             rsp_homekit_decrypt_data;
	struct gecko_msg_homekit_encrypt_data_rsp_t                             rsp_homekit_encrypt_data;
	struct gecko_msg_homekit_get_pairing_id_rsp_t                           rsp_homekit_get_pairing_id;

	uint8 payload[128];/*TODO: fix this in nativeclient_parser.py*/
})data;

};
extern struct gecko_cmd_packet* gecko_cmd_msg;
extern struct gecko_cmd_packet* gecko_rsp_msg;
void gecko_handle_command(uint32_t,void*);
void gecko_handle_command_noresponse(uint32_t,void*);
/**This command can be used to reset the system. This command does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) after re-boot. **/
static inline void* gecko_cmd_dfu_reset(uint8 dfu) 
{
	gecko_cmd_msg->data.cmd_dfu_reset.dfu=dfu;
	gecko_cmd_msg->header=gecko_cmd_dfu_reset_id+((1+0)<<8);
	gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
	return 0;
}
/**After re-booting the local device into DFU mode, this command can be used to define the starting address on the flash to where the new firmware will be written in.**/
static inline struct gecko_msg_dfu_flash_set_address_rsp_t* gecko_cmd_dfu_flash_set_address(uint32 address) 
{
	gecko_cmd_msg->data.cmd_dfu_flash_set_address.address=address;
	gecko_cmd_msg->header=gecko_cmd_dfu_flash_set_address_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_dfu_flash_set_address;
}
/**This command can be used to upload the whole firmware image file in to the Bluetooth device. The recommended payload size of the command is 128 bytes, so multiple commands need to be issued one after the other until the whole .bin firmware image file is uploaded to the device. The next address of the flash sector in memory to write to is automatically updated by the bootloader after each individual command.**/
static inline struct gecko_msg_dfu_flash_upload_rsp_t* gecko_cmd_dfu_flash_upload(uint8 data_len,const uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_dfu_flash_upload.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_dfu_flash_upload.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_dfu_flash_upload_id+((1+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
}
/**This command can be used to tell to the device that the DFU file has been fully uploaded. To return the device back to normal mode the command {a href="#cmd_dfu_reset"}DFU Reset {/a} must be issued next.**/
static inline struct gecko_msg_dfu_flash_upload_finish_rsp_t* gecko_cmd_dfu_flash_upload_finish() 
{
	gecko_cmd_msg->header=gecko_cmd_dfu_flash_upload_finish_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_dfu_flash_upload_finish;
}
/**This command does not trigger any event but the response to the command is used to verify that communication between the host and the device is working.**/
static inline struct gecko_msg_system_hello_rsp_t* gecko_cmd_system_hello() 
{
	gecko_cmd_msg->header=gecko_cmd_system_hello_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_system_hello;
}
/**
            This command can be used to reset the system. It does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) depending on the selected boot mode.**/
static inline void* gecko_cmd_system_reset(uint8 dfu) 
{
	gecko_cmd_msg->data.cmd_system_reset.dfu=dfu;
	gecko_cmd_msg->header=gecko_cmd_system_reset_id+((1+0)<<8);
	gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
	return 0;
}
/**This command can be used to read the LE public address used by the device.**/
static inline struct gecko_msg_system_get_bt_address_rsp_t* gecko_cmd_system_get_bt_address() 
{
	gecko_cmd_msg->header=gecko_cmd_system_get_bt_address_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_system_get_bt_address;
}
/**
                This command can be used to set the TX power. It returns the power that was set. If the GATT server contains a Tx Power service, the Tx Power Level attribute of the service will be updated accordingly.

                {p}{b}NOTE:{/b} This command should not be used while advertising, scanning or during connection.{/p}
            **/
static inline struct gecko_msg_system_set_tx_power_rsp_t* gecko_cmd_system_set_tx_power(int16 power) 
{
	gecko_cmd_msg->data.cmd_system_set_tx_power.power=power;
	gecko_cmd_msg->header=gecko_cmd_system_set_tx_power_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_system_set_tx_power;
}
/**
                This command can be used to get random data up to 16 bytes.
            **/
static inline struct gecko_msg_system_get_random_data_rsp_t* gecko_cmd_system_get_random_data(uint8 length) 
{
	gecko_cmd_msg->data.cmd_system_get_random_data.length=length;
	gecko_cmd_msg->header=gecko_cmd_system_get_random_data_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_system_get_random_data;
}
/**This command can be used to connect an advertising device. Scanning parameters can be configured with the le_gap_set_scan_parameters command before issuing this command. To cancel on an ongoing connection process use the endpoint_close command. {p}A connection is opened in no-security mode. If the GATT client needs to read or write the attributes on GATT server requiring encryption or authentication, it must first encrypt the connection using an appropriate authentication method.{/p} {p}This command fails with "Out Of Memory" error if the number of connections attempted to be opened exceeds the max_connections value configured in project file.{/p}**/
static inline struct gecko_msg_le_gap_open_rsp_t* gecko_cmd_le_gap_open(bd_addr address,uint8 address_type) 
{
	memcpy(&gecko_cmd_msg->data.cmd_le_gap_open.address,&address,sizeof(bd_addr));
	gecko_cmd_msg->data.cmd_le_gap_open.address_type=address_type;
	gecko_cmd_msg->header=gecko_cmd_le_gap_open_id+((7+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_open;
}
/**This command can be used to configure the current Bluetooth LE GAP Connectable and Discoverable modes. It can be used to enable advertisements and/or allow incoming connections. To exit from this mode (to stop advertising and/or disallow incoming connections), issue this command with the Not Discoverable / Not Connectable parameter values.
                        Command will take effect immediately. If currently set parameters can't be used with new mode then an error will be returned.
            **/
static inline struct gecko_msg_le_gap_set_mode_rsp_t* gecko_cmd_le_gap_set_mode(uint8 discover,uint8 connect) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_mode.discover=discover;
	gecko_cmd_msg->data.cmd_le_gap_set_mode.connect=connect;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_mode_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_mode;
}
/**This command can be used to start the GAP discovery procedure to scan for advertising devices, that is to perform a device discovery. Scanning parameters 
            can be configured with the {a href="#cmd_le_gap_set_scan_parameters"}le_gap_set_scan_parameters{/a} command before issuing this command. To cancel an ongoing 
            discovery process use the {a href="#cmd_le_gap_end_procedure"}le_gap_end_procedure{/a} command.**/
static inline struct gecko_msg_le_gap_discover_rsp_t* gecko_cmd_le_gap_discover(uint8 mode) 
{
	gecko_cmd_msg->data.cmd_le_gap_discover.mode=mode;
	gecko_cmd_msg->header=gecko_cmd_le_gap_discover_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_discover;
}
/**This command can be used to end a current GAP procedure.**/
static inline struct gecko_msg_le_gap_end_procedure_rsp_t* gecko_cmd_le_gap_end_procedure() 
{
	gecko_cmd_msg->header=gecko_cmd_le_gap_end_procedure_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_end_procedure;
}
/**This command can be used to set Bluetooth LE advertisement parameters.
            Parameters will take effect immediately, if parameters can't be used with currently active mode an error will be returned.**/
static inline struct gecko_msg_le_gap_set_adv_parameters_rsp_t* gecko_cmd_le_gap_set_adv_parameters(uint16 interval_min,uint16 interval_max,uint8 channel_map) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_min=interval_min;
	gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_max=interval_max;
	gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.channel_map=channel_map;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_parameters_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_adv_parameters;
}
/**This command can be used to set the default Bluetooth LE connection parameters. The configured values are valid for all subsequent connections that will 
            be established. For changing the parameters of an already established connection use the command {a href="#cmd_le_connection_set_parameters"}le_connection_set_parameters{/a}.**/
static inline struct gecko_msg_le_gap_set_conn_parameters_rsp_t* gecko_cmd_le_gap_set_conn_parameters(uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.min_interval=min_interval;
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.max_interval=max_interval;
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.latency=latency;
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.timeout=timeout;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_conn_parameters_id+((8+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_conn_parameters;
}
/**This command can be used to set Bluetooth LE scan parameters.**/
static inline struct gecko_msg_le_gap_set_scan_parameters_rsp_t* gecko_cmd_le_gap_set_scan_parameters(uint16 scan_interval,uint16 scan_window,uint8 active) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_interval=scan_interval;
	gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_window=scan_window;
	gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.active=active;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_scan_parameters_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_scan_parameters;
}
/**This command can be used together with {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to advertise user defined data. First use this command to set the data in advertisement packets and/or in the scan response packets, and then use command {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to configure this device to be discoverable in user_data mode. 
                {p}Note that the user defined data may be overwritten by the system when this device is later configured to other discoverable mode than user_data. It is recommended to set both the advertisement data and scan response data at the same time.{/p}
                {p}If advertisement mode is currently active, then new advertisement data will be used immediately.{/p}**/
static inline struct gecko_msg_le_gap_set_adv_data_rsp_t* gecko_cmd_le_gap_set_adv_data(uint8 scan_rsp,uint8 adv_data_len,const uint8* adv_data_data) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_adv_data.scan_rsp=scan_rsp;
	gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.len=adv_data_len;
	memcpy(gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_data_id+((2+adv_data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
}
/****/
static inline struct gecko_msg_le_gap_set_adv_timeout_rsp_t* gecko_cmd_le_gap_set_adv_timeout(uint8 intervals) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_adv_timeout.intervals=intervals;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_timeout_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_adv_timeout;
}
/**This command can be used to request a change in the connection parameters of a Bluetooth LE connection.**/
static inline struct gecko_msg_le_connection_set_parameters_rsp_t* gecko_cmd_le_connection_set_parameters(uint8 connection,uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout) 
{
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.connection=connection;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.min_interval=min_interval;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.max_interval=max_interval;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.latency=latency;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.timeout=timeout;
	gecko_cmd_msg->header=gecko_cmd_le_connection_set_parameters_id+((9+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_connection_set_parameters;
}
/**This command can be used to get the latest RSSI value of a BLE connection.**/
static inline struct gecko_msg_le_connection_get_rssi_rsp_t* gecko_cmd_le_connection_get_rssi(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_le_connection_get_rssi.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_le_connection_get_rssi_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_connection_get_rssi;
}
/**This command temporarily enables or disables slave latency. Used only when Bluetooth device is in slave role.**/
static inline struct gecko_msg_le_connection_disable_slave_latency_rsp_t* gecko_cmd_le_connection_disable_slave_latency(uint8 connection,uint8 disable) 
{
	gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.connection=connection;
	gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.disable=disable;
	gecko_cmd_msg->header=gecko_cmd_le_connection_disable_slave_latency_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_connection_disable_slave_latency;
}
/**This command can be used to set the maximum number of GATT Message Transfer Units (MTU). If max_mtu is non-default, MTU is exchanged automatically after Bluetooth LE connection has been established.**/
static inline struct gecko_msg_gatt_set_max_mtu_rsp_t* gecko_cmd_gatt_set_max_mtu(uint16 max_mtu) 
{
	gecko_cmd_msg->data.cmd_gatt_set_max_mtu.max_mtu=max_mtu;
	gecko_cmd_msg->header=gecko_cmd_gatt_set_max_mtu_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_set_max_mtu;
}
/**This command can be used to discover all the primary services of a remote GATT database. This command generates a unique gatt_service event for 
            every discovered primary service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure 
            has successfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_primary_services_rsp_t* gecko_cmd_gatt_discover_primary_services(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_primary_services.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_primary_services_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services;
}
/**This command can be used to discover primary services with the specified UUID in a remote GATT database. This command generates unique gatt_service event for every discovered primary service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t* gecko_cmd_gatt_discover_primary_services_by_uuid(uint8 connection,uint8 uuid_len,const uint8* uuid_data) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.len=uuid_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.data,uuid_data,uuid_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_primary_services_by_uuid_id+((2+uuid_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
}
/**This command can be used to discover all characteristics of the defined GATT service from a remote GATT database. This command generates a unique gatt_characteristic event for every discovered characteristic. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_characteristics_rsp_t* gecko_cmd_gatt_discover_characteristics(uint8 connection,uint32 service) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics.service=service;
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_characteristics_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics;
}
/**This command can be used to discover all the characteristics of the specified GATT service in a remote GATT database having the specified UUID. This command
generates a unique gatt_characteristic event for every discovered
characteristic having the specified UUID. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that
this GATT procedure has successfully completed or failed with error.
            **/
static inline struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t* gecko_cmd_gatt_discover_characteristics_by_uuid(uint8 connection,uint32 service,uint8 uuid_len,const uint8* uuid_data) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.service=service;
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.len=uuid_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.data,uuid_data,uuid_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_characteristics_by_uuid_id+((6+uuid_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
}
/**This command can be used to enable or disable the notifications and indications being sent from a remote GATT server. This procedure discovers a 
            characteristic client configuration descriptor and writes the related configuration flags to a remote GATT database. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event
            indicates that this GATT procedure has successfully completed or that is has failed with an error.**/
static inline struct gecko_msg_gatt_set_characteristic_notification_rsp_t* gecko_cmd_gatt_set_characteristic_notification(uint8 connection,uint16 characteristic,uint8 flags) 
{
	gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_gatt_set_characteristic_notification_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_set_characteristic_notification;
}
/**This command can be used to discover all the descriptors of the specified remote GATT characteristics in a remote GATT database. This command generates a unique gatt_descriptor event for every discovered descriptor. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_descriptors_rsp_t* gecko_cmd_gatt_discover_descriptors(uint8 connection,uint16 characteristic) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_descriptors.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_descriptors.characteristic=characteristic;
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_descriptors_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_descriptors;
}
/**This command can be used to read the value of a characteristic from a remote GATT database. A single {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} event is generated 
            if the length of the characteristic value returned by the remote GATT server is less than or equal to the size of the GATT MTU. If the length of the value 
            exceeds the size of the GATT MTU more than one {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} event is generated because the firmware will automatically use the "read long" 
            GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_characteristic_value_rsp_t* gecko_cmd_gatt_read_characteristic_value(uint8 connection,uint16 characteristic) 
{
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.characteristic=characteristic;
	gecko_cmd_msg->header=gecko_cmd_gatt_read_characteristic_value_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value;
}
/**This command can be used to read the characteristic value of a service from a remote GATT database by giving the UUID of the characteristic and the 
            handle of the service containing this characteristic. A single {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} event is generated if the length of the characteristic value returned by the 
            remote GATT server is less than or equal to the size of the GATT MTU. If the length of the value exceeds the size of the GATT MTU more than one 
            {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} event is generated because the firmware will automatically use the "read long" GATT procedure. 
            A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t* gecko_cmd_gatt_read_characteristic_value_by_uuid(uint8 connection,uint32 service,uint8 uuid_len,const uint8* uuid_data) 
{
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.service=service;
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.len=uuid_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.data,uuid_data,uuid_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_read_characteristic_value_by_uuid_id+((6+uuid_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
}
/**This command can be used to write the value of a characteristic in a remote GATT database. If the length of the given value is greater than 
            the exchanged GATT MTU (Message Transfer Unit), "write long" GATT procedure is used automatically. Received 
            {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all data has been written successfully or that an error response 
            has been received.**/
static inline struct gecko_msg_gatt_write_characteristic_value_rsp_t* gecko_cmd_gatt_write_characteristic_value(uint8 connection,uint16 characteristic,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_write_characteristic_value_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
}
/**This command can be used to write the value of a characteristic in a
            remote GATT database. This command does not generate any event. All failures on the server are ignored silently. 
            For example, if an error is generated in the remote GATT server and the given value is not written into database no error message will be reported to the local 
            GATT client. Note that this command cannot be used to write long values.**/
static inline struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t* gecko_cmd_gatt_write_characteristic_value_without_response(uint8 connection,uint16 characteristic,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_write_characteristic_value_without_response_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
}
/**This command can be used to add a characteristic value to the write queue of a remote GATT server. 
            This command can be used in cases where very long attributes need to be written, or a set of values needs to be written atomically.
            In all cases where the amount of data to transfer fits into the BGAPI payload the command 
            {a href="#cmd_gatt_write_characteristic_value"}gatt_write_characteristic_value{/a} is recommended for writing long values since it transparently 
            performs the prepare_write and execute_write commands. Writes are executed or cancelled with the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.
            Whether the writes succeeded or not are indicated in the response of the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.
            **/
static inline struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.offset=offset;
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_prepare_characteristic_value_write_id+((6+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
}
/**This command can be used to commit or cancel previously queued writes to a long characteristic of a remote GATT server.
            Writes are sent to queue with {a href="#cmd_gatt_prepare_characteristic_value_write"}prepare_characteristic_value_write{/a} command. 
            Content, offset and length of queued values are validated by this procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a}
            event indicates that all data has been written successfully or that an error response has been received.
            **/
static inline struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t* gecko_cmd_gatt_execute_characteristic_value_write(uint8 connection,uint8 flags) 
{
	gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_gatt_execute_characteristic_value_write_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_execute_characteristic_value_write;
}
/**This command must be used to send a characteristic confirmation to a remote GATT server after receiving an indication. 
            The {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value_event{/a} carries the att_opcode containing handle_value_indication (0x1e) which reveals 
            that an indication has been received and this must be confirmed with this command. Confirmation needs to be sent within 30 seconds, otherwise the GATT transactions 
            between the client and the server are discontinued.**/
static inline struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t* gecko_cmd_gatt_send_characteristic_confirmation(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_gatt_send_characteristic_confirmation.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_gatt_send_characteristic_confirmation_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_send_characteristic_confirmation;
}
/**This command can be used to read the descriptor value of a characteristic in a remote GATT database. A single {a href="#evt_gatt_descriptor_value"}
            gatt_descriptor_value{/a} event is  generated if the length of the descriptor value returned by the remote GATT server is less than or equal to the size of the 
            GATT MTU. If the length of the value exceeds the size of the GATT MTU more than one {a href="#evt_gatt_descriptor_value"}gatt_descriptor_value{/a} event is generated because the firmware 
            will automatically use the "read long" GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all 
            data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_descriptor_value_rsp_t* gecko_cmd_gatt_read_descriptor_value(uint8 connection,uint16 descriptor) 
{
	gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.descriptor=descriptor;
	gecko_cmd_msg->header=gecko_cmd_gatt_read_descriptor_value_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_descriptor_value;
}
/**This command can be used to write the value of a characteristic descriptor in a remote GATT database. If the length of the given value is greater 
            than the exchanged GATT MTU size, "write long" GATT procedure is used automatically. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} 
            event indicates that all data has been written succesfully or that an error response has been received.
            **/
static inline struct gecko_msg_gatt_write_descriptor_value_rsp_t* gecko_cmd_gatt_write_descriptor_value(uint8 connection,uint16 descriptor,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.descriptor=descriptor;
	gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_write_descriptor_value_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
}
/**This command can be used to find out if a service of a remote GATT database includes one or more other services. This command generates a unique gatt_service_completed event for each included service. This command generates a unique gatt_service event for every discovered service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has successfully completed or failed with error.**/
static inline struct gecko_msg_gatt_find_included_services_rsp_t* gecko_cmd_gatt_find_included_services(uint8 connection,uint32 service) 
{
	gecko_cmd_msg->data.cmd_gatt_find_included_services.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_find_included_services.service=service;
	gecko_cmd_msg->header=gecko_cmd_gatt_find_included_services_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_find_included_services;
}
/**This command can be used to read the values of multiple characteristics from a remote GATT database at once. 
            {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} events are generated as the values are returned by the remote GATT server.
            A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that either all data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t* gecko_cmd_gatt_read_multiple_characteristic_values(uint8 connection,uint8 characteristic_list_len,const uint8* characteristic_list_data) 
{
	gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.len=characteristic_list_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.data,characteristic_list_data,characteristic_list_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_read_multiple_characteristic_values_id+((2+characteristic_list_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
}
/**This command can be used to read the value of an attribute from a local GATT database.**/
static inline struct gecko_msg_gatt_server_read_attribute_value_rsp_t* gecko_cmd_gatt_server_read_attribute_value(uint16 attribute,uint16 offset) 
{
	gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.attribute=attribute;
	gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.offset=offset;
	gecko_cmd_msg->header=gecko_cmd_gatt_server_read_attribute_value_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_value;
}
/**This command can be used to read the type of an attribute from a local GATT database. The type is a UUID, usually 16 or 128 bits long.**/
static inline struct gecko_msg_gatt_server_read_attribute_type_rsp_t* gecko_cmd_gatt_server_read_attribute_type(uint16 attribute) 
{
	gecko_cmd_msg->data.cmd_gatt_server_read_attribute_type.attribute=attribute;
	gecko_cmd_msg->header=gecko_cmd_gatt_server_read_attribute_type_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_type;
}
/**This command can be used to write the value of an attribute in the local GATT database. Writing the value of a characteristic of the local GATT database 
            will not trigger notifications or indications to the remote GATT client in case such characteristic has property of indicate or notify and the client has enabled 
            notification or indication. Notifications and indications are sent to the remote GATT client using {a href="#cmd_gatt_server_send_characteristic_notification"}
            gatt_server_send_characteristic_notification{/a} command.**/
static inline struct gecko_msg_gatt_server_write_attribute_value_rsp_t* gecko_cmd_gatt_server_write_attribute_value(uint16 attribute,uint16 offset,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.attribute=attribute;
	gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.offset=offset;
	gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_server_write_attribute_value_id+((5+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
}
/**This command must be used to send a response to a {a href="#evt_gatt_server_user_read_request"}user_read_request{/a} event. The response needs to be sent within 30 second, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the characteristic value is sent to the remote GATT client in the normal way. Other attr_errorcode 
            values will cause the local GATT server to send an attribute protocol error response instead of the actual data.**/
static inline struct gecko_msg_gatt_server_send_user_read_response_rsp_t* gecko_cmd_gatt_server_send_user_read_response(uint8 connection,uint16 characteristic,uint8 att_errorcode,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.att_errorcode=att_errorcode;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_server_send_user_read_response_id+((5+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
}
/**This command must be used to send a response to a {a href="#evt_gatt_server_user_write_request"}gatt_server_user_write_request{/a} event. The response needs to be sent within 30 seconds, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the ATT protocol's write response is sent to indicate to the remote GATT client that 
            the write operation was processed successfully. Other values will cause the local GATT server to send an ATT protocol error response.**/
static inline struct gecko_msg_gatt_server_send_user_write_response_rsp_t* gecko_cmd_gatt_server_send_user_write_response(uint8 connection,uint16 characteristic,uint8 att_errorcode) 
{
	gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.att_errorcode=att_errorcode;
	gecko_cmd_msg->header=gecko_cmd_gatt_server_send_user_write_response_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_send_user_write_response;
}
/**This command can be used to send notifications or indications to a remote GATT client. Notification or indication is sent only if the client has enabled 
            them by setting the corresponding flag to the Client Characteristic Configuration descriptor. A new notification or indication cannot be sent before a confirmation 
            from the GATT client is first received. The confirmation is indicated by {a href="#evt_gatt_server_characteristic_status"}gatt_server_characteristic_status event{/a}.**/
static inline struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t* gecko_cmd_gatt_server_send_characteristic_notification(uint8 connection,uint16 characteristic,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_server_send_characteristic_notification_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
}
/**This command can be used to find attributes of certain type from a local GATT database. Type is usually given as 16-bit or 128-bit UUID.**/
static inline struct gecko_msg_gatt_server_find_attribute_rsp_t* gecko_cmd_gatt_server_find_attribute(uint16 start,uint8 type_len,const uint8* type_data) 
{
	gecko_cmd_msg->data.cmd_gatt_server_find_attribute.start=start;
	gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.len=type_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.data,type_data,type_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_server_find_attribute_id+((3+type_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_find_attribute;
}
/**This command can be used to send data to the defined endpoint.**/
static inline struct gecko_msg_endpoint_send_rsp_t* gecko_cmd_endpoint_send(uint8 endpoint,uint8 data_len,const uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_endpoint_send.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_send.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_endpoint_send.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_endpoint_send_id+((2+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_send;
}
/**This command can be used to set the destination into which data from an endpoint will be routed to.**/
static inline struct gecko_msg_endpoint_set_streaming_destination_rsp_t* gecko_cmd_endpoint_set_streaming_destination(uint8 endpoint,uint8 destination_endpoint) 
{
	gecko_cmd_msg->data.cmd_endpoint_set_streaming_destination.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_set_streaming_destination.destination_endpoint=destination_endpoint;
	gecko_cmd_msg->header=gecko_cmd_endpoint_set_streaming_destination_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_set_streaming_destination;
}
/**This command can be used to close an endpoint. This command must always be used to close an endpoint with WAIT_CLOSE status. This is to free the endpoint for future reuse in the case when the remote side closes the connection.**/
static inline struct gecko_msg_endpoint_close_rsp_t* gecko_cmd_endpoint_close(uint8 endpoint) 
{
	gecko_cmd_msg->data.cmd_endpoint_close.endpoint=endpoint;
	gecko_cmd_msg->header=gecko_cmd_endpoint_close_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_close;
}
/**This command can be used to set endpoint flags to control and/or indicate in which mode the endpoint connection is operating.**/
static inline struct gecko_msg_endpoint_set_flags_rsp_t* gecko_cmd_endpoint_set_flags(uint8 endpoint,uint32 flags) 
{
	gecko_cmd_msg->data.cmd_endpoint_set_flags.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_set_flags.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_endpoint_set_flags_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_set_flags;
}
/**This command can be used to clear endpoint flags.**/
static inline struct gecko_msg_endpoint_clr_flags_rsp_t* gecko_cmd_endpoint_clr_flags(uint8 endpoint,uint32 flags) 
{
	gecko_cmd_msg->data.cmd_endpoint_clr_flags.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_clr_flags.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_endpoint_clr_flags_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_clr_flags;
}
/**This command can be used to read the data performance counters (data sent counter and data received counter) of an endpoint.**/
static inline struct gecko_msg_endpoint_read_counters_rsp_t* gecko_cmd_endpoint_read_counters(uint8 endpoint) 
{
	gecko_cmd_msg->data.cmd_endpoint_read_counters.endpoint=endpoint;
	gecko_cmd_msg->header=gecko_cmd_endpoint_read_counters_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_read_counters;
}
/**This command can be used to start a software timer. Multiple concurrent timers can be running simultaneously. There are 256 unique timer ID's available,
            but in practice the amount of concurrent timers is limited by the amount of free memory.**/
static inline struct gecko_msg_hardware_set_soft_timer_rsp_t* gecko_cmd_hardware_set_soft_timer(uint32 time,uint8 handle,uint8 single_shot) 
{
	gecko_cmd_msg->data.cmd_hardware_set_soft_timer.time=time;
	gecko_cmd_msg->data.cmd_hardware_set_soft_timer.handle=handle;
	gecko_cmd_msg->data.cmd_hardware_set_soft_timer.single_shot=single_shot;
	gecko_cmd_msg->header=gecko_cmd_hardware_set_soft_timer_id+((6+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_set_soft_timer;
}
/**This command can be used to configure the mode of an I/O port. After a boot, the device uses the default settings defined in hardware.xml, and this command can used to override the default settings. 
            Note that GPIO configurations set with this command do not persist over a reset.**/
static inline struct gecko_msg_hardware_configure_gpio_rsp_t* gecko_cmd_hardware_configure_gpio(uint8 port,uint8 gpio,uint8 mode,uint8 output) 
{
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.port=port;
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.gpio=gpio;
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.mode=mode;
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.output=output;
	gecko_cmd_msg->header=gecko_cmd_hardware_configure_gpio_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_configure_gpio;
}
/**This command can be used to set the logic states of pins of the specified I/O-port using a bitmask.**/
static inline struct gecko_msg_hardware_write_gpio_rsp_t* gecko_cmd_hardware_write_gpio(uint8 port,uint16 mask,uint16 data) 
{
	gecko_cmd_msg->data.cmd_hardware_write_gpio.port=port;
	gecko_cmd_msg->data.cmd_hardware_write_gpio.mask=mask;
	gecko_cmd_msg->data.cmd_hardware_write_gpio.data=data;
	gecko_cmd_msg->header=gecko_cmd_hardware_write_gpio_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_write_gpio;
}
/**This command can be used to read the pins of the specified I/O-port of the device.**/
static inline struct gecko_msg_hardware_read_gpio_rsp_t* gecko_cmd_hardware_read_gpio(uint8 port,uint16 mask) 
{
	gecko_cmd_msg->data.cmd_hardware_read_gpio.port=port;
	gecko_cmd_msg->data.cmd_hardware_read_gpio.mask=mask;
	gecko_cmd_msg->header=gecko_cmd_hardware_read_gpio_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_read_gpio;
}
/**This command can be used to read the specified GPIO pin analog value.**/
static inline struct gecko_msg_hardware_read_adc_rsp_t* gecko_cmd_hardware_read_adc(uint8 port,uint8 pin) 
{
	gecko_cmd_msg->data.cmd_hardware_read_adc.port=port;
	gecko_cmd_msg->data.cmd_hardware_read_adc.pin=pin;
	gecko_cmd_msg->header=gecko_cmd_hardware_read_adc_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_read_adc;
}
/**This command can be used to configure the ADC reference. Default reference is VDD.**/
static inline struct gecko_msg_hardware_config_adc_reference_rsp_t* gecko_cmd_hardware_config_adc_reference(uint8 reference) 
{
	gecko_cmd_msg->data.cmd_hardware_config_adc_reference.reference=reference;
	gecko_cmd_msg->header=gecko_cmd_hardware_config_adc_reference_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_config_adc_reference;
}
/**This command can be used to read from the specified I2C interface. The I2C interfaces must be configured in the hardware.xml file, as described in the device Configuration Guide.**/
static inline struct gecko_msg_hardware_read_i2c_rsp_t* gecko_cmd_hardware_read_i2c(uint8 channel,uint16 slave_address,uint8 length) 
{
	gecko_cmd_msg->data.cmd_hardware_read_i2c.channel=channel;
	gecko_cmd_msg->data.cmd_hardware_read_i2c.slave_address=slave_address;
	gecko_cmd_msg->data.cmd_hardware_read_i2c.length=length;
	gecko_cmd_msg->header=gecko_cmd_hardware_read_i2c_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_read_i2c;
}
/**This command can be used to write data into I2C interface. The I2C interfaces must be configured in the hardware.xml file, as described in the device Configuration Guide.**/
static inline struct gecko_msg_hardware_write_i2c_rsp_t* gecko_cmd_hardware_write_i2c(uint8 channel,uint16 slave_address,uint8 data_len,const uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_hardware_write_i2c.channel=channel;
	gecko_cmd_msg->data.cmd_hardware_write_i2c.slave_address=slave_address;
	gecko_cmd_msg->data.cmd_hardware_write_i2c.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_hardware_write_i2c.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_hardware_write_i2c_id+((4+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_write_i2c;
}
/**This command can be used to stop I2C transmission.**/
static inline struct gecko_msg_hardware_stop_i2c_rsp_t* gecko_cmd_hardware_stop_i2c(uint8 channel) 
{
	gecko_cmd_msg->data.cmd_hardware_stop_i2c.channel=channel;
	gecko_cmd_msg->header=gecko_cmd_hardware_stop_i2c_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_stop_i2c;
}
/**This command can be used to configure the UART interface.**/
static inline struct gecko_msg_hardware_set_uart_configuration_rsp_t* gecko_cmd_hardware_set_uart_configuration(uint8 index,uint32 baud_rate,uint8 data_bits,uint8 stop_bits,uint8 parity,uint8 flow_ctrl) 
{
	gecko_cmd_msg->data.cmd_hardware_set_uart_configuration.index=index;
	gecko_cmd_msg->data.cmd_hardware_set_uart_configuration.baud_rate=baud_rate;
	gecko_cmd_msg->data.cmd_hardware_set_uart_configuration.data_bits=data_bits;
	gecko_cmd_msg->data.cmd_hardware_set_uart_configuration.stop_bits=stop_bits;
	gecko_cmd_msg->data.cmd_hardware_set_uart_configuration.parity=parity;
	gecko_cmd_msg->data.cmd_hardware_set_uart_configuration.flow_ctrl=flow_ctrl;
	gecko_cmd_msg->header=gecko_cmd_hardware_set_uart_configuration_id+((9+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_set_uart_configuration;
}
/**This command can be used to read the specified channel of ADC.**/
static inline struct gecko_msg_hardware_read_adc_channel_rsp_t* gecko_cmd_hardware_read_adc_channel(uint8 channel) 
{
	gecko_cmd_msg->data.cmd_hardware_read_adc_channel.channel=channel;
	gecko_cmd_msg->header=gecko_cmd_hardware_read_adc_channel_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_read_adc_channel;
}
/**Get elapsed time since last reset of RTCC**/
static inline struct gecko_msg_hardware_get_time_rsp_t* gecko_cmd_hardware_get_time() 
{
	gecko_cmd_msg->header=gecko_cmd_hardware_get_time_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_get_time;
}
/**This command can be used to start a software timer with some slack. Slack parameter allows stack to optimize wake ups and save power. Timer event is triggered between time and time + slack. See also description of {a href="#cmd_hardware_set_soft_timer"}hardware_set_soft_timer{/a} command.**/
static inline struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t* gecko_cmd_hardware_set_lazy_soft_timer(uint32 time,uint32 slack,uint8 handle,uint8 single_shot) 
{
	gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.time=time;
	gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.slack=slack;
	gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.handle=handle;
	gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.single_shot=single_shot;
	gecko_cmd_msg->header=gecko_cmd_hardware_set_lazy_soft_timer_id+((10+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_set_lazy_soft_timer;
}
/**This command can be used to enable or disable DC/DC.**/
static inline struct gecko_msg_hardware_enable_dcdc_rsp_t* gecko_cmd_hardware_enable_dcdc(uint8 enable) 
{
	gecko_cmd_msg->data.cmd_hardware_enable_dcdc.enable=enable;
	gecko_cmd_msg->header=gecko_cmd_hardware_enable_dcdc_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_enable_dcdc;
}
/**This command can be used to retrieve all PS keys and their current values. For each existing PS key a flash_pskey event will be generated which includes the corresponding PS key value.**/
static inline struct gecko_msg_flash_ps_dump_rsp_t* gecko_cmd_flash_ps_dump() 
{
	gecko_cmd_msg->header=gecko_cmd_flash_ps_dump_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_dump;
}
/**This command can be used to erase all PS keys and their corresponding values.**/
static inline struct gecko_msg_flash_ps_erase_all_rsp_t* gecko_cmd_flash_ps_erase_all() 
{
	gecko_cmd_msg->header=gecko_cmd_flash_ps_erase_all_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_erase_all;
}
/**This command can be used to store a value into the specified PS key. Allowed PS keys are in range from 0x4000 to 0x407F**/
static inline struct gecko_msg_flash_ps_save_rsp_t* gecko_cmd_flash_ps_save(uint16 key,uint8 value_len,const uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_flash_ps_save.key=key;
	gecko_cmd_msg->data.cmd_flash_ps_save.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_flash_ps_save.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_flash_ps_save_id+((3+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_save;
}
/**This command can be used for retrieving the value of the specified PS key.**/
static inline struct gecko_msg_flash_ps_load_rsp_t* gecko_cmd_flash_ps_load(uint16 key) 
{
	gecko_cmd_msg->data.cmd_flash_ps_load.key=key;
	gecko_cmd_msg->header=gecko_cmd_flash_ps_load_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_load;
}
/**This command can be used to erase a single PS key and its value from the persistent store..**/
static inline struct gecko_msg_flash_ps_erase_rsp_t* gecko_cmd_flash_ps_erase(uint16 key) 
{
	gecko_cmd_msg->data.cmd_flash_ps_erase.key=key;
	gecko_cmd_msg->header=gecko_cmd_flash_ps_erase_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_erase;
}
/**
                This command can be used to start a transmitter test. The test is meant to be used against a separate Bluetooth tester device. When the command is processed by the radio, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered. This event indicates if the test started successfully.

                {p}In the transmitter test, the device sends packets continuously with a fixed interval. The type and length of each packet is set by {b}packet_type{/b} and {b}length{/b} parameters. There is also a special packet type, {b}test_pkt_carrier{/b}, which can be used to transmit continuous unmodulated carrier. The {b}length{/b} field is ignored in this mode.{/p}

                {p}The test may be stopped using the {a href="#cmd_test_dtm_end"}test_dtm_end{/a} command.{/p}
            **/
static inline struct gecko_msg_test_dtm_tx_rsp_t* gecko_cmd_test_dtm_tx(uint8 packet_type,uint8 length,uint8 channel) 
{
	gecko_cmd_msg->data.cmd_test_dtm_tx.packet_type=packet_type;
	gecko_cmd_msg->data.cmd_test_dtm_tx.length=length;
	gecko_cmd_msg->data.cmd_test_dtm_tx.channel=channel;
	gecko_cmd_msg->header=gecko_cmd_test_dtm_tx_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_test_dtm_tx;
}
/**
                This command can be used to start a receiver test. The test is meant to be used against a separate Bluetooth tester device. When the command is processed by the radio, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered. This event indicates if the test started successfully.

                {p}The test may be stopped using the {a href="#cmd_test_dtm_end"}test_dtm_end{/a} command. This will trigger another {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event, which carries the number of packets received during the test.{/p}
            **/
static inline struct gecko_msg_test_dtm_rx_rsp_t* gecko_cmd_test_dtm_rx(uint8 channel) 
{
	gecko_cmd_msg->data.cmd_test_dtm_rx.channel=channel;
	gecko_cmd_msg->header=gecko_cmd_test_dtm_rx_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_test_dtm_rx;
}
/**
                This command can be used to end a transmitter or a receiver test. When the command is processed by the radio and the test has ended, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered.
            **/
static inline struct gecko_msg_test_dtm_end_rsp_t* gecko_cmd_test_dtm_end() 
{
	gecko_cmd_msg->header=gecko_cmd_test_dtm_end_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_test_dtm_end;
}
/**This command can be used to set whether the device accepts new bondings or not.**/
static inline struct gecko_msg_sm_set_bondable_mode_rsp_t* gecko_cmd_sm_set_bondable_mode(uint8 bondable) 
{
	gecko_cmd_msg->data.cmd_sm_set_bondable_mode.bondable=bondable;
	gecko_cmd_msg->header=gecko_cmd_sm_set_bondable_mode_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_set_bondable_mode;
}
/**This command can be used to configure security requirements and I/O capabilities of the system.**/
static inline void* gecko_cmd_sm_configure(uint8 flags,uint8 io_capabilities) 
{
	gecko_cmd_msg->data.cmd_sm_configure.flags=flags;
	gecko_cmd_msg->data.cmd_sm_configure.io_capabilities=io_capabilities;
	gecko_cmd_msg->header=gecko_cmd_sm_configure_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.payload;
}
/**This command can be used to set maximum allowed bonding count and bonding policy.**/
static inline struct gecko_msg_sm_store_bonding_configuration_rsp_t* gecko_cmd_sm_store_bonding_configuration(uint8 max_bonding_count,uint8 policy_flags) 
{
	gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.max_bonding_count=max_bonding_count;
	gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.policy_flags=policy_flags;
	gecko_cmd_msg->header=gecko_cmd_sm_store_bonding_configuration_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_store_bonding_configuration;
}
/**This command can be used to enhance the security of a connection to current security requirements. On an unencrypted connection, this will encrypt the connection and will also perform bonding if requested by both devices. On an encrypted connection, this will cause the connection re-encrypted.**/
static inline struct gecko_msg_sm_increase_security_rsp_t* gecko_cmd_sm_increase_security(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_sm_increase_security.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_sm_increase_security_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_increase_security;
}
/**This command can be used to delete specified bonding information from Persistent Store.**/
static inline struct gecko_msg_sm_delete_bonding_rsp_t* gecko_cmd_sm_delete_bonding(uint8 bonding) 
{
	gecko_cmd_msg->data.cmd_sm_delete_bonding.bonding=bonding;
	gecko_cmd_msg->header=gecko_cmd_sm_delete_bonding_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_delete_bonding;
}
/**This command can be used to delete all bonding information from Persistent Store.**/
static inline struct gecko_msg_sm_delete_bondings_rsp_t* gecko_cmd_sm_delete_bondings() 
{
	gecko_cmd_msg->header=gecko_cmd_sm_delete_bondings_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_delete_bondings;
}
/**This command can be used to enter a passkey after receiving a passkey request event.**/
static inline struct gecko_msg_sm_enter_passkey_rsp_t* gecko_cmd_sm_enter_passkey(uint8 connection,uint32 passkey) 
{
	gecko_cmd_msg->data.cmd_sm_enter_passkey.connection=connection;
	gecko_cmd_msg->data.cmd_sm_enter_passkey.passkey=passkey;
	gecko_cmd_msg->header=gecko_cmd_sm_enter_passkey_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_enter_passkey;
}
/**
                This command can be used to set the OOB data (out-of-band encryption data) for a device. The OOB data may be, for example, a PIN code exchanged over 
                an alternate path like NFC. The device will not allow any other kind of bonding if OOB data is set.
            **/
static inline struct gecko_msg_sm_set_oob_data_rsp_t* gecko_cmd_sm_set_oob_data(uint8 oob_data_len,const uint8* oob_data_data) 
{
	gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.len=oob_data_len;
	memcpy(gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.data,oob_data_data,oob_data_len);
	gecko_cmd_msg->header=gecko_cmd_sm_set_oob_data_id+((1+oob_data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_set_oob_data;
}
/**This command can be used to list all bondings stored in the bonding database. Bondings are reported by using the {a href="#evt_sm_list_bonding_entry"}
            sm_list_bonding_entry{/a} event for each bonding and the report is ended with {a href="#evt_sm_list_all_bondings_complete"}sm_list_all_bondings_complete{/a} event. 
            Recommended to be used only for debugging purposes, because reading from the Persistent Store is relatively slow.**/
static inline struct gecko_msg_sm_list_all_bondings_rsp_t* gecko_cmd_sm_list_all_bondings() 
{
	gecko_cmd_msg->header=gecko_cmd_sm_list_all_bondings_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_list_all_bondings;
}
/**
            Converts decimal value in ASCII string to 32-bit signed integer.
            **/
static inline struct gecko_msg_util_atoi_rsp_t* gecko_cmd_util_atoi(uint8 string_len,const uint8* string_data) 
{
	gecko_cmd_msg->data.cmd_util_atoi.string.len=string_len;
	memcpy(gecko_cmd_msg->data.cmd_util_atoi.string.data,string_data,string_len);
	gecko_cmd_msg->header=gecko_cmd_util_atoi_id+((1+string_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_util_atoi;
}
/**
            This command can be used to convert a 32-bit signed integer value into a decimal value represented as a string.
            **/
static inline struct gecko_msg_util_itoa_rsp_t* gecko_cmd_util_itoa(int32 value) 
{
	gecko_cmd_msg->data.cmd_util_itoa.value=value;
	gecko_cmd_msg->header=gecko_cmd_util_itoa_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_util_itoa;
}
/**Set HomeKit configuration**/
static inline struct gecko_msg_homekit_configure_rsp_t* gecko_cmd_homekit_configure(uint8 i2c_address,uint8 support_display,uint8 hap_features) 
{
	gecko_cmd_msg->data.cmd_homekit_configure.i2c_address=i2c_address;
	gecko_cmd_msg->data.cmd_homekit_configure.support_display=support_display;
	gecko_cmd_msg->data.cmd_homekit_configure.hap_features=hap_features;
	gecko_cmd_msg->header=gecko_cmd_homekit_configure_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_homekit_configure;
}
/**Start/stop HomeKit accessory advertising**/
static inline struct gecko_msg_homekit_advertise_rsp_t* gecko_cmd_homekit_advertise(uint8 enable,uint16 category) 
{
	gecko_cmd_msg->data.cmd_homekit_advertise.enable=enable;
	gecko_cmd_msg->data.cmd_homekit_advertise.category=category;
	gecko_cmd_msg->header=gecko_cmd_homekit_advertise_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_homekit_advertise;
}
/**Delete all HomeKit pairing information data**/
static inline struct gecko_msg_homekit_delete_pairings_rsp_t* gecko_cmd_homekit_delete_pairings() 
{
	gecko_cmd_msg->header=gecko_cmd_homekit_delete_pairings_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_homekit_delete_pairings;
}
/**This function make a I2C test connection with Apple authentication coprocesor and return error if communication fail**/
static inline struct gecko_msg_homekit_check_authcp_rsp_t* gecko_cmd_homekit_check_authcp() 
{
	gecko_cmd_msg->header=gecko_cmd_homekit_check_authcp_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_homekit_check_authcp;
}
/**Function make a decryption HomeKit data**/
static inline struct gecko_msg_homekit_decrypt_data_rsp_t* gecko_cmd_homekit_decrypt_data(uint8 connection,uint8 data_len,const uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_homekit_decrypt_data.connection=connection;
	gecko_cmd_msg->data.cmd_homekit_decrypt_data.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_homekit_decrypt_data.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_homekit_decrypt_data_id+((2+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_homekit_decrypt_data;
}
/**Function make a encryption HomeKit data**/
static inline struct gecko_msg_homekit_encrypt_data_rsp_t* gecko_cmd_homekit_encrypt_data(uint8 connection,uint8 data_len,const uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_homekit_encrypt_data.connection=connection;
	gecko_cmd_msg->data.cmd_homekit_encrypt_data.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_homekit_encrypt_data.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_homekit_encrypt_data_id+((2+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_homekit_encrypt_data;
}
/**Get pairing ID of connected iOS device.**/
static inline struct gecko_msg_homekit_get_pairing_id_rsp_t* gecko_cmd_homekit_get_pairing_id(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_homekit_get_pairing_id.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_homekit_get_pairing_id_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_homekit_get_pairing_id;
}

#ifdef __cplusplus
}
#endif

#endif
